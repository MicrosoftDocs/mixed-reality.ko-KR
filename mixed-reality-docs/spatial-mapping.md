---
title: 공간 매핑
description: 공간 매핑은 HoloLens 주위 환경의 실제 표면에 대 한 자세한 표현을 제공 합니다.
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 공간 매핑, HoloLens, 혼합 현실, 표면 재구성, 메시, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 915d3cc63a5571ba22ac4608589f3eca8da1bc81
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/24/2019
ms.locfileid: "63550501"
---
# <a name="spatial-mapping"></a>공간 매핑

공간 매핑은 HoloLens를 중심으로 환경의 실제 표면에 대 한 세부 정보를 제공 하 여 개발자가 설득 혼합 현실 환경을 만들 수 있도록 합니다. 응용 프로그램은 실제 세계를 가상 세계와 병합 하 여 holograms를 실제 상태로 만들 수 있습니다. 친숙 한 실제 동작 및 상호 작용을 제공 하 여 응용 프로그램을 보다 자연스럽 게 사용자 기대에 맞출 수도 있습니다.

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a>장치 지원

<table>
<tr>
<th>기능</th><th style="width:150px"> <a href="hololens-hardware-details.md">HoloLens(1세대)</a></th><th style="width:150px">HoloLens 2</th><th style="width:150px"> <a href="immersive-headset-hardware-details.md">몰입형 헤드셋</a></th>
</tr><tr>
<td> 공간 매핑</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"> ✔️</td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a>개념적 개요

![대화방을 덮고 있는 메시 서피스](images/SurfaceReconstruction.jpg)<br>
*공간을 다루는 공간 매핑 메시의 예*

공간 매핑에 사용 되는 두 가지 기본 개체 형식은 ' 공간 표면 관찰자 ' 및 ' 공간 표면 '입니다.

응용 프로그램은 공간 표면 관찰자에 하나 이상의 경계 볼륨을 제공 하 여 응용 프로그램이 공간 매핑 데이터를 받으려는 공간 영역을 정의 합니다. 이러한 각 볼륨에 대해 공간 매핑은 공간 표면의 집합을 응용 프로그램에 제공 합니다.

이러한 볼륨은 실제 세계와 관련 하 여 고정 된 위치에 고정 되어 있거나, HoloLens에 연결 될 수 있습니다 (환경에서 이동할 때 HoloLens로 이동 하 고 회전 하지 않음). 각 공간 표면은 세계 잠긴 [공간 좌표계](coordinate-systems.md)에 연결 된 삼각형 망으로 표시 되는 작은 공간의 실제 표면에 대해 설명 합니다.

HoloLens가 환경에 대 한 새 데이터를 수집 하 고 환경에 대 한 변경 사항이 발생 하면 공간 서피스가 표시 되 고 사라지고 변경 됩니다.

## <a name="common-usage-scenarios"></a>일반적인 사용 시나리오

![일반적인 공간 매핑 사용 시나리오의 그림: 배치, 폐색, 물리 및 탐색](images/sm-concepts-1000px.png)

### <a name="placement"></a>배치

공간 매핑은 응용 프로그램에 사용자에 게 친숙 하 고 친숙 한 형태의 상호 작용을 제공할 수 있는 기회를 제공 합니다. 책상에 전화를 넣는 것 보다 자연스럽 게 무엇을 할 수 있나요?

Holograms (또는 더 일반적으로 공간 위치 선택)의 배치를 화면에 배치 하는 것은 3D (지점에서의 경우)에서 2D (point on surface)로의 자연 스러운 매핑을 제공 합니다. 이를 통해 사용자가 응용 프로그램에 제공 해야 하는 정보의 양을 줄이고 사용자의 상호 작용을 보다 쉽고 정확 하 게 수행할 수 있습니다. ' 거리가 먼 쪽 '은 다른 사용자나 컴퓨터와 물리적으로 통신 하는 데 사용 되는 항목이 아니기 때문에 특히 그렇습니다. 손가락을 가리키면 거리가 아니라 방향을 지정 합니다.

여기서 중요 한 점은 응용 프로그램이 방향에서 거리를 유추 하는 경우 (예: 사용자의 응시 방향에 따라 가장 가까운 공간 화면을 찾기 위해 raycast를 수행 하는 경우), 사용자가 안정적으로 예측할 수 있는 결과를 생성 해야 한다는 것입니다. 그렇지 않으면 사용자가 제어를 사용할 수 없게 되 고,이로 인해 속도가 어려울 수 있습니다. 이렇게 하는 데 도움이 되는 한 가지 방법은 하나만 사용 하는 것이 아니라 여러 raycasts를 수행 하는 것입니다. 집계 결과는 보다 빠르고 예측 가능 하며 일시적 ' 이상 ' 결과에 영향을 미칠 수 있습니다. 즉, 작은 구멍이 나 사용자가 인식 하지 않는 작은 기 하 도형 비트에 도달 하 여 발생 하는 광선에 의해 발생 하는 경우에 발생 합니다. 집계 또는 다듬기를 시간에 따라 수행할 수도 있습니다. 예를 들어 사용자의 거리에 따라 홀로그램의 최대 속도를 제한할 수 있습니다. 최소 및 최대 거리 값을 제한 하는 것도 도움이 될 수 있으므로, 이동 하는 홀로그램은 갑자기 멀리 이동 하거나 사용자의 얼굴에 다시 충돌 하지 않습니다.

응용 프로그램은 표면의 모양과 방향을 사용 하 여 홀로그램 배치를 안내할 수도 있습니다. Holographic의 상태는 벽을 통과 해서는 안 되며, 약간 불균형 하지 않아도 바닥을 가만히 두어야 합니다. 이러한 종류의 기능은 raycasts 보다는 물리학 충돌을 사용 하는 경우에만 적용 될 수 있지만 유사한 우려 사항이 적용 됩니다. 배치 된 홀로그램에 한도의 다리와 같이 눈에 잘 지는 작은 다각형이 많이 있는 경우에는 해당 다각형의 물리학 표현을 더 광범위 하 고 매끄럽게 확장 하 여 snagging.

사용자 입력은 전적으로 간단 하 게 만들 수 있으며 공간 표면을 사용 하 여 전체 자동 홀로그램 배치를 수행할 수 있습니다. 예를 들어, 응용 프로그램은 사용자가 누르기 위해 벽 어딘가에 holographic을 둘 수 있습니다. 예측 가능성에 대 한 동일한 주의 사항은 여기에서 이중으로 적용 됩니다. 사용자가 홀로그램 배치를 제어할 것으로 예상 하지만 응용 프로그램이 예상 위치에 holograms를 배치 하지 않는 경우 (빛 스위치가 사용자에 게 도달할 수 없는 어딘가에 표시 되는 경우)이는 불편 한 경험입니다. 사용자가 항상 배치를 수행 해야 하는 것 보다 사용자를 수정 해야 하는 자동 배치를 수행 하는 것이 더 낮을 수 있습니다. 자동 배치가 *정상적*으로 수행 되기 때문에 수동 수정은 부담이 되는 것 처럼 보입니다.

또한 배치를 위해 공간 표면을 사용 하는 응용 프로그램의 기능은 응용 프로그램의 [검색 환경](spatial-mapping-design.md#the-environment-scanning-experience)에 따라 크게 달라 집니다. 표면이 스캔 되지 않은 경우 배치에 사용할 수 없습니다. 새 화면을 검색 하거나 새 위치를 선택할 수 있도록 사용자에 게이를 명확 하 게 표시 하는 것은 응용 프로그램의 것입니다.

사용자에 게 시각적 피드백은 배치 중 가장 중요 한 것입니다. 사용자는 [접지 효과가](spatial-mapping.md#visualization)있는 가장 가까운 서피스와 관련 하 여 홀로그램의 위치를 알고 있어야 합니다. 홀로그램의 이동이 제한 되는 이유를 이해 해야 합니다 (예: 인접 한 다른 표면과의 충돌로 인해). 현재 위치에 홀로그램을 저장할 수 없는 경우 시각적 피드백을 통해 이유를 명확 하 게 해야 합니다. 예를 들어 사용자가 holographic 소파를 벽에 고정 하 려 하는 경우 벽 뒤에 있는 소파의 부분은 화난 색으로 pulsate 됩니다. 반대로 응용 프로그램이 실제 화면을 볼 수 있는 위치에서 공간 화면을 찾을 수 없는 경우 응용 프로그램에서이를 명확 하 게 해야 합니다. 이 영역에서 접지 효과가 확실 하지 않은 것은이 목적을 달성할 수 있습니다.

### <a name="occlusion"></a>폐색

공간 매핑 표면의 주요 용도 중 하나는 단순히 려 holograms입니다. 이 간단한 동작은 holograms의 인식 된 현실감에 상당한 영향을 주므로 실제로 사용자와 동일한 물리적 공간을 inhabit 하는 visceral sense를 만듭니다.

또한 폐색는 사용자에 게 정보를 제공 합니다. 홀로그램은 실제 표면에 의해 폐색 보이는 것 처럼 보이지만 전 세계의 해당 홀로그램 공간 위치에 대 한 추가 시각적 피드백을 제공 합니다. 반대로 폐색는 사용자 로부터 정보를 유용한 *숨길* 수도 있습니다. 벽이 occluding holograms은 직관적인 방식으로 시각적 개체를 줄일 수 있습니다. 홀로그램을 숨기 거 나 표시 하려면 사용자가 자신의 헤드를 이동 하기만 하면 됩니다.

폐색를 사용 하 여 친숙 한 물리적 상호 작용을 기반으로 자연 사용자 인터페이스에 대 한 기대를 파악할 수도 있습니다. 홀로그램을 표면에 폐색 하는 경우 해당 서피스가 solid 이기 때문입니다. 따라서 사용자는 홀로그램이 해당 화면과 *충돌* 하 고 단순히 전달 하는 것은 아닙니다.

경우에 따라 holograms의 폐색는 바람직하지 않습니다. 사용자가 홀로그램과 상호 작용할 수 있어야 하는 경우 실제 화면에 있는 경우에도 해당 사용자를 볼 수 있어야 합니다. 이러한 경우 일반적으로 폐색 때 이러한 홀로그램을 다르게 렌더링 하는 것이 좋습니다 (예: 밝기 감소). 이러한 방식으로 사용자는 홀로그램를 시각적으로 찾을 수는 있지만 그 뒤에도 계속 인식 됩니다.

### <a name="physics"></a>물리

물리 시뮬레이션을 사용 하는 또 다른 방법은 공간 매핑을 사용 하 여 사용자의 실제 공간에서 holograms의 *존재* 를 강화할 수 있는 또 다른 방법입니다. 내 holographic 고무 공이 우리 책상에서 사실적으로 롤업되 면 바닥에 바운스 하 고 소파 아래에 사라지면 서 실제로는 그렇지 않다고 생각 하는 것이 어려울 수 있습니다.

또한 물리학 시뮬레이션에서는 응용 프로그램이 자연스럽 고 친숙 한 물리학 기반 상호 작용을 사용할 수 있는 기회를 제공 합니다. Holographic 가구의 피스를 이동 하는 것은 가구가 적절 한 관성 및 마찰으로 바닥을 슬라이딩 하는 것 처럼 반응 하는 경우 사용자에 게 더 쉬울 수 있습니다.

실제 동작을 생성 하기 위해 구멍 채우기, 부동 hallucinations 제거 및 대략적인 표면 다듬기와 같은 몇 가지 [메시 처리](spatial-mapping.md#mesh-processing) 를 수행 해야 합니다.

응용 프로그램의 [검사 환경이](spatial-mapping-design.md#the-environment-scanning-experience) 물리학 시뮬레이션에 미치는 영향을 고려해 야 합니다. 첫째, 누락 된 표면은 어떤 것 과도 충돌 하지 않습니다. 고무 공이 어느에서 벗어나 알려진 세계의 끝에서 롤업되 면 어떻게 되나요? 둘째로, 시간이 지남에 따라 환경의 변화에 대 한 응답을 계속할지 여부를 결정 해야 합니다. 경우에 따라 최대한 신속 하 게 응답 하는 것이 좋습니다. 사용자가 들어오는 로마 화살표의 템 피스트에 대해 방어에서 이동 가능한 barricades로 도어 및 가구를 사용 하 고 있다고 가정 합니다. 그러나 다른 경우에는 새 업데이트를 무시 하는 것이 좋습니다. holographic 스포츠 자동차를 바닥의 트랙 가운데에 배치 하기로 결정 한 경우에는이를 통해 재미 없게 될 수 있습니다.

### <a name="navigation"></a>탐색

응용 프로그램은 공간 매핑 데이터를 사용 하 여 실제 사용자와 동일한 방식으로 실제 세계를 탐색 하는 기능을 holographic 문자 (또는 에이전트)에 게 부여할 수 있습니다. 이렇게 하면 사용자와 사용자의 친구와 동일한 자연스럽 고 친숙 한 동작 집합으로 제한 하 여 holographic 문자를 더욱 쉽게 확인할 수 있습니다.

탐색 기능은 사용자에 게 유용할 수도 있습니다. 지정 된 영역에서 탐색 맵을 작성 한 후에는 해당 위치에 익숙하지 않은 새 사용자에 대 한 holographic 방향을 제공 하도록 공유할 수 있습니다. 이 맵은 보행자의 ' 교통 ' 트래픽을 원활 하 게 전달 하거나 생성 사이트와 같은 위험한 위치에서 사고를 방지할 수 있도록 설계 되었습니다.

탐색 기능을 구현 하는 것과 관련 된 핵심 기술 과제는 walkable 표면 (사람이 테이블을 탐색 하지 않음)을 안정적으로 검색 하 고 환경의 변화에 대 한 적절 한 적응 (사람이 폐쇄형 도어를 통하지 않음)을 수행 하는 것입니다. 메시는 경로 계획 및 가상 문자 탐색에 사용할 수 있도록 하기 전에 몇 가지 [처리](spatial-mapping.md#mesh-processing) 를 요구할 수 있습니다. 메시를 매끄럽게 하 고 hallucinations를 제거 하면 문자가 중단 되지 않도록 방지할 수 있습니다. 또한 문자의 경로 계획 및 탐색 계산 속도를 높이기 위해 메시를 크게 간소화할 수 있습니다. 이러한 문제는 videogame 기술 개발에 상당한 주의가 필요 하며, 이러한 주제에 대 한 다양 한 연구 자료를 제공 합니다.

Unity의 기본 제공 NavMesh 기능은 공간 매핑 화면에서 사용할 수 없습니다. 이는 응용 프로그램이 시작 될 때 까지는 공간 매핑 서피스가 알려지지 않지만 NavMesh 데이터 파일은 미리 원본 자산에서 생성 되어야 하기 때문입니다. 또한 공간 매핑 시스템은 사용자의 현재 위치에서 멀리 [떨어진 화면에 대 한 정보](spatial-mapping-design.md#the-environment-scanning-experience) 를 제공 하지 않습니다. 따라서 응용 프로그램은 매우 큰 영역의 지도를 빌드하는 경우 화면 자체를 ' 주의 ' 해야 합니다.

### <a name="visualization"></a>시각화

대부분의 경우 공간 표면을 표시 하지 않는 것이 좋습니다. 시각적으로 혼란을 최소화 하 고 실제 세계를 대상으로 말할 수 있습니다. 그러나 실제 관련 항목이 이미 표시 되어 있더라도 공간 매핑 표면을 직접 시각화 하는 것이 유용한 경우도 있습니다.

예를 들어 사용자가 표면에 홀로그램을 배치 하려고 할 때 (예: 벽에 holographic 캐비닛 배치) 그림자를 화면으로 캐스팅 하 여 홀로그램을 ' 그라운드 ' 하는 데 유용할 수 있습니다. 이렇게 하면 사용자에 게 홀로그램과 표면 사이의 정확한 물리적 근접 한 의미가 제공 됩니다. 사용자가 커밋하기 전에 변경을 시각적으로 ' 미리 보기 ' 하는 일반적인 방법의 예 이기도 합니다.

응용 프로그램은 화면을 시각화 하 여 환경에 대 한 이해를 사용자와 공유할 수 있습니다. 예를 들어 holographic board game은 ' 테이블 '로 식별 된 가로 표면을 시각화할 수 있으므로 사용자가 상호 작용 해야 하는 위치를 알 수 있습니다.

화면 시각화는 뷰에서 숨겨진 사용자에 게 인접 한 공간을 표시 하는 데 유용한 방법일 수 있습니다. 이를 통해 사용자가 거실에서 부엌 (그리고 포함 된 모든 holograms)에 액세스할 수 있는 간단한 방법을 제공할 수 있습니다.

공간 매핑에서 제공 되는 surface 메시는 특히 ' clean ' 일 수 없습니다. 따라서 적절 하 게 시각화 하는 것이 중요 합니다. 기존 조명 계산은 시각적으로 혼란을 주는 방식으로 표면 법선의 오류를 강조 표시할 수 있습니다. 화면에 표시 되는 ' 깨끗 ' 질감은 tidier 모양을 제공 하는 데 도움이 될 수 있습니다. 표면이 렌더링 되기 전에 메시 속성을 개선 하기 위해 [메시 처리](spatial-mapping.md#mesh-processing) 를 수행할 수도 있습니다.

## <a name="using-the-surface-observer"></a>Surface 관찰자 사용

공간 매핑의 시작점은 표면 관찰자입니다. 프로그램 흐름은 다음과 같습니다.
* Surface 관찰자 개체 만들기
   * 하나 이상의 공간 볼륨을 제공 하 여 응용 프로그램이 공간 매핑 데이터를 받을 대상 영역을 정의 합니다. 공간 볼륨은 단지 구 또는 상자와 같은 공간의 영역을 정의 하는 셰이프입니다.
   * 세계에서 잠긴 공간 좌표계를 사용 하 여 공간 볼륨을 사용 하 여 실제 세계의 고정 영역을 식별 합니다.
   * 공간 볼륨을 사용 하 여 본문 잠김 공간 좌표계로 각 프레임을 업데이트 하 고 사용자와의 이동 (회전 하지는 않음) 하는 공간의 영역을 식별 합니다.
   * 이러한 공간 볼륨은 나중에 언제 든 지 응용 프로그램 또는 사용자의 상태가 변경 됨에 따라 변경 될 수 있습니다.
* 폴링 또는 알림을 사용 하 여 공간 표면에 대 한 정보 검색
   * 언제 든 지 공간 노출 상태에 대 한 표면 관찰자를 ' 폴링할 ' 수 있습니다. 또는 공간 서피스가 변경 될 때 응용 프로그램에 알리는 surface 관찰자의 ' 표면 변경 ' 이벤트를 등록할 수 있습니다.
   * 뷰 하위 수준 또는 본문 잠금 볼륨과 같은 동적 공간 볼륨의 경우, 응용 프로그램은 관심 영역을 설정 하 고 현재 공간 표면의 집합을 가져와 각 프레임의 변경을 폴링합니다.
   * 단일 대화방을 포함 하는 세계에서 잠긴 큐브와 같은 정적 볼륨의 경우 응용 프로그램에서 ' surface changed ' 이벤트를 등록 하 여 해당 볼륨 내의 공간 표면이 변경 되었을 때 알리도록 할 수 있습니다.
* 프로세스 표면 변경
   * 제공 된 공간 표면의 집합을 반복 합니다.
   * 공간 표면을 추가, 변경 또는 제거 된 것으로 분류 합니다.
   * 추가 되거나 변경 된 각 공간 표면의 경우 적절 한 세부 수준에서 표면의 현재 상태를 나타내는 업데이트 된 메시를 수신 하는 비동기 요청을 적절 하 게 제출 합니다.
* 비동기 메시 요청을 처리 합니다 (다음 섹션에서 자세히 설명).

## <a name="mesh-caching"></a>메시 캐싱

공간 표면은 조밀한 삼각형 메시로 표시 됩니다. 이러한 메시를 저장, 렌더링 및 처리 하면 중요 한 계산 및 저장소 리소스를 사용할 수 있습니다. 따라서 메시 처리 및 저장소에 사용 되는 리소스를 최소화 하기 위해 각 응용 프로그램은 요구 사항에 적합 한 메시 캐싱 체계를 채택 해야 합니다. 이 체계는 유지할 메시와 삭제할 메시와 각 공간 표면의 메시를 업데이트할 시기를 결정 해야 합니다.

여기에서 설명 하는 대부분의 고려 사항은 응용 프로그램이 메시 캐싱에 접근 하는 방법을 직접 알려 줍니다. 사용자가 환경에서 이동 하는 방법, 여러 서피스가 관찰 될 때, 환경의 변경 내용을 캡처해야 하는 경우를 고려해 야 합니다.

Surface 관찰자가 제공 하는 ' 표면 변화 ' 이벤트를 해석할 때 기본 메시 캐싱 논리는 다음과 같습니다.
* 응용 프로그램에서 이전에 확인 되지 않은 공간 노출 ID를 확인 하는 경우이를 새로운 공간 표면으로 처리 해야 합니다.
* 응용 프로그램에서 지정 된 ID를 가진 공간 표면의 새 업데이트 시간을 확인 하는 경우이를 업데이트 된 공간 화면으로 처리 해야 합니다.
* 응용 프로그램에서 더 이상 알려진 ID의 공간 표면을 인식 하지 못하는 경우 제거 된 공간 서피스로이를 처리 해야 합니다.

각 응용 프로그램은 다음과 같이 선택 해야 합니다.
* 새 공간 표면의 경우 메시를 요청 해야 하나요?
   * 일반적으로 메시는 사용자에 게 유용한 새 정보를 제공할 수 있는 새 공간 표면에 대해 즉시 요청 되어야 합니다.
   * 그러나 사용자 앞의 및 앞에 있는 새 공간 표면에 우선 순위를 지정 하 고 해당 메시를 먼저 요청 해야 합니다.
   * 새 메쉬가 필요 하지 않은 경우, 예를 들어 응용 프로그램이 환경 모델을 영구적으로 또는 일시적으로 ' 고정 ' 하는 경우 요청 하지 않아야 합니다.
* 업데이트 된 공간 표면의 경우 메시를 요청 해야 하나요?
   * 사용자의 앞과 뒤에 있는 업데이트 된 공간 화면에 우선 순위를 지정 하 고 해당 메시를 먼저 요청 해야 합니다.
   * 특히 스캔 환경에서 업데이트 된 표면 보다 새 표면에 더 높은 우선 순위를 부여 하는 것이 적합할 수도 있습니다.
   * 처리 비용을 제한 하기 위해 응용 프로그램은 공간 표면의 업데이트를 처리 하는 속도를 제한 하고자 할 수 있습니다.
   * 예를 들어 표면의 범위가 작은 경우 (예: 표면의 범위가 작은 경우), 처리 하는 데 충분 하지 않을 수 있습니다.
   * 사용자를 대상으로 하는 현재 영역 외부의 공간 표면의 업데이트는 완전히 무시 될 수 있지만,이 경우 surface 관찰자가 사용 하는 공간 경계 볼륨을 수정 하는 것이 더 효율적일 수 있습니다.
* 제거 된 공간 표면의 경우 메시를 삭제 해야 하나요?
   * 일반적으로 메시는 제거 된 공간 표면에 대해 즉시 삭제 되어야 하므로 홀로그램 폐색는 올바른 상태로 유지 됩니다.
   * 그러나 응용 프로그램에서 공간 표면이 잠시 후 (사용자 환경의 디자인을 기반으로) 다시 나타나도록 하는 이유가 있는 경우 메시를 삭제 하 고 나중에 다시 만드는 것 보다 더 효율적일 수 있습니다.
   * 응용 프로그램에서 사용자 환경의 대규모 모델을 빌드하는 경우에는 메시를 전혀 삭제 하지 않을 수 있습니다. 공간 서피스가 사라질 때 메시를 디스크로 스풀링하는 경우에도 리소스 사용량을 제한 해야 합니다.
   * 공간 surface를 생성 하는 동안 비교적 드물게 발생 하는 일부 이벤트는 다른 Id를 사용 하 여 비슷한 위치의 새 공간 서피스로 공간 표면을 대체할 수 있습니다. 따라서 제거 된 화면을 삭제 하지 않도록 선택 하는 응용 프로그램은 동일한 위치를 포함 하는 여러 개의 매우 겹치는 공간 노출 망으로 끝나지 않도록 주의 해야 합니다.
* 다른 공간 표면의 메시를 삭제 해야 하나요?
   * 공간 표면이 있는 동안에도 사용자 환경에 더 이상 유용 하지 않은 경우에는 삭제 해야 합니다. 예를 들어, 응용 프로그램이 이르는 길의 다른 쪽에 있는 대화방을 대체 가상 공간으로 대체 하는 경우 해당 공간의 공간 표면이 더 이상 중요 하지 않습니다.

다음은 공간 및 임시 임계값을 사용 하는 메시 캐싱 전략의 예입니다.
* 사용자의 응시를 따르는 것과 같이 두 부분으로 이루어진 공간 볼륨을 사용 하려는 응용 프로그램을 살펴보세요.
* 사용자가 화면에서 멀리 떨어진 곳에서 또는 그 밖의 단계에서 멀리 떨어져 있기 때문에 공간 표면이 일시적으로이 볼륨에서 사라질 수 있습니다 ... 뒤로 다시 조회 하거나 나중에 다시 이동 합니다. 이 경우이 화면에 대 한 메시를 삭제 하 고 다시 만드는 작업은 많은 중복 처리를 나타냅니다.
* 처리 되는 변경 내용 수를 줄이기 위해 응용 프로그램은 서로 다른 두 개의 공간 노출 관찰자를 사용 합니다. 더 큰 볼륨은 구형 이며 사용자가 ' 지연 ' 됩니다. 사용자의 중앙에서 2.0 metres 내에 있는지 확인 하는 데 필요한 경우에만 이동 합니다.
* 새 공간 및 업데이트 된 공간 노출 메시는 항상 작은 내부 표면 관찰자에서 처리 되지만 메시는 더 큰 외부 표면 관찰자에서 사라질 때까지 캐시 됩니다. 이를 통해 응용 프로그램은 로컬 사용자 이동으로 인해 여러 중복 된 변경 내용의 처리를 방지할 수 있습니다.
* 공간 표면은 추적 손실로 인해 일시적으로 사라질 수도 있으므로 응용 프로그램은 손실을 추적 하는 동안 제거 된 공간 표면의 삭제를 지연 하기도 합니다.
* 일반적으로 응용 프로그램은 최적의 캐싱 전략을 결정 하기 위해 줄어든 업데이트 처리와 메모리 사용량 증가 간의 균형을 평가 해야 합니다.

## <a name="rendering"></a>렌더링

공간 매핑 메시를 렌더링에 사용 하는 세 가지 기본 방법은 다음과 같습니다.
* Surface 시각화
   * 공간 표면을 직접 시각화 하는 것이 유용한 경우가 많습니다. 예를 들어 개체에서 공간 표면으로 ' shadows '를 캐스팅 하면 표면에 holograms 배치 하는 동안 사용자에 게 유용한 시각적 피드백을 제공할 수 있습니다.
   * 공간 메시는 3D 음악가에서 만들 수 있는 메시의 종류와는 다르다는 점입니다. 삼각형 토폴로지는 사람이 만든 토폴로지에서는 ' 정리 ' 되지 않으며 메시는 [다양 한 오류를 발생](spatial-mapping-design.md#what-influences-spatial-mapping-quality)시킬 수 있습니다.
   * 보기 편 visual 미적를 만들기 위해 구멍 또는 부드러운 표면 법선을 채우기 위해 일부 [메시 처리](spatial-mapping.md#mesh-processing)를 수행 하는 것이 좋습니다. 메시 토폴로지 및 법선을 직접 시각화 하는 대신 셰이더를 사용 하 여 삽화에서 디자인 한 질감을 망상에 프로젝션 할 수도 있습니다.
* 실제 세계 표면 뒤의 occluding holograms
   * 공간 표면은 깊이 [버퍼](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) 에만 영향을 주며 색 렌더링 대상에는 영향을 주지 않는 깊이 전용 패스에서 렌더링할 수 있습니다.
   * 이렇게 하면 prime는 깊이 버퍼를 려 공간 표면의 뒤에 렌더링 된 holograms 합니다. Holograms의 정확한 폐색은 실제로 사용자의 실제 공간 내에 존재 하는 의미를 향상 시킵니다.
   * 깊이 전용 렌더링을 사용 하려면 모든 색 렌더링 대상에 대해 blend 상태를 업데이트 하 여 [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) 을 0으로 설정 합니다.
* 실제 표면에의 한 holograms 폐색의 모양 수정
   * 일반적으로 렌더링 된 기 하 도형은 폐색 때 숨겨집니다. 이렇게 하려면 [깊이 스텐실 상태](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) 에서 깊이 함수를 "작거나 같음"으로 설정 합니다. 이렇게 하면 이전에 렌더링 된 모든 기 하 도형 보다 카메라에 **가까이** 있는 경우에만 기 하 도형을 볼 수 있습니다.
   * 그러나 폐색 경우에도 특정 기 하 도형을 표시 하 고 사용자에 게 시각적 피드백을 제공 하는 방법으로 폐색 때 모양을 수정 하는 것이 유용할 수 있습니다. 예를 들어,이를 통해 응용 프로그램은 실제 화면 뒤에 있는 개체의 위치를 명확 하 게 표시할 수 있습니다.
   * 이렇게 하려면 원하는 ' 폐색 ' 모양을 만드는 다른 셰이더를 사용 하 여 기 하 도형을 두 번째로 렌더링 합니다. 기 하 도형을 두 번째로 렌더링 하기 전에 [깊이 스텐실 상태](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)를 두 번 변경 해야 합니다. 먼저, 이전에 렌더링 된 모든 기 하 도형 보다 카메라에서 **추가** 된 경우에만 기 하 도형을 볼 수 있도록 깊이 함수를 "크거나 같음"으로 설정 합니다. 그런 다음 DepthWriteMask를 0으로 설정 하 여 깊이 버퍼가 수정 되지 않도록 합니다. 깊이 버퍼는 카메라와 **가장 가까운** 기 하 도형의 깊이를 계속 표시 합니다.

공간 매핑 메시를 렌더링할 때 [성능은](understanding-performance-for-mixed-reality.md) 중요 한 문제입니다. 다음은 공간 매핑 메시 렌더링과 관련 된 몇 가지 렌더링 성능 기술입니다.
* 삼각형 밀도 조정
   * 표면 관찰자 로부터 공간 표면 메시를 요청 하는 경우 요구 사항에 충분 한 삼각형 메시의 가장 낮은 밀도를 요청 합니다.
   * 사용자의 표면 거리 및 사용자 환경에 대 한 관련성에 따라 표면의 표면에서 삼각형 밀도를 변경 하는 것이 적합할 수 있습니다.
   * 삼각형 수를 줄이면 픽셀 처리 비용에는 영향을 주지 않지만 GPU에서 메모리 사용량 및 꼭 짓 점 처리 비용이 줄어듭니다.
* 고르기를 수행 합니다.
   * 두 번째 고르기는 현재 표시의 외부에 있기 때문에 볼 수 없는 그리기 개체를 건너뜁니다. 그러면 CPU와 GPU 처리 비용이 줄어듭니다.
   * 고르기는 메시 마다 수행 되 고 공간 표면은 클 수 있으므로 공간 표면이 클 수 있습니다. 각 공간 표면 메시를 작은 청크로 나누면 더 효율적인 고르기 (이 경우에는 더 적은 수의 스크린 된 삼각형이 렌더링 됨)가 생성 될 수 있습니다. 그러나 다음과 같은 단점이 있습니다. 메시가 많을 수록 더 많은 그리기 호출을 수행 해야 하므로 CPU 비용이 늘어날 수 있습니다. 극단적인 경우에는 대/소문자 고르기 계산 자체에서 CPU 비용이 측정 될 수도 있습니다.
* 렌더링 순서 조정
   * 공간 표면은이를 둘러싼 사용자의 전체 환경을 나타내므로 공간 표면은 클 수 있습니다. 따라서 GPU에 대 한 픽셀 처리 비용은 특히 표시 되는 기 하 도형 (공간 서피스와 기타 holograms 모두 포함)의 계층이 둘 이상 있는 경우에 더 높을 수 있습니다. 이 경우 사용자에 게 가장 가까운 계층은 모든 계층을 occluding 하 게 되므로 더 멀리 떨어져 있는 계층을 렌더링 하는 데 걸린 GPU 시간은 낭비 됩니다.
   * GPU에서 이러한 중복 작업을 줄이기 위해 불투명 표면을 앞에서 뒤로 순서로 렌더링 하는 데 도움이 됩니다. ' 불투명 '은 [깊이 스텐실 상태](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)에서 DepthWriteMask가 1로 설정 된 표면을 의미 합니다. 가장 가까운 서피스가 렌더링 되 면 GPU의 픽셀 프로세서에서 더 멀리 떨어져 있는 표면을 효율적으로 건너뛰도록 깊이 버퍼를 소수 대로 설정 합니다.

## <a name="mesh-processing"></a>메시 처리

응용 프로그램은 요구 사항에 맞게 공간 노출 메시에 대해 [다양 한 작업](spatial-mapping.md#mesh-processing) 을 수행 하려고 할 수 있습니다. 각 공간 표면 메시와 함께 제공 되는 인덱스 및 꼭 짓 점 데이터는 모든 최신 렌더링 Api에서 삼각형 메시를 렌더링 하는 데 사용 되는 [꼭 짓 점 및 인덱스 버퍼](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) 와 동일한 익숙한 레이아웃을 사용 합니다. 그러나 기억해 야 할 한 가지 중요 한 사실은 공간 매핑 삼각형에 **시계 반대 방향 굴곡 순서가**있다는 것입니다. 각 삼각형은 메시의 인덱스 버퍼에서 3 개의 꼭 짓 점 인덱스로 표시 되 고, 이러한 인덱스는 삼각형이 **front** 에서 표시 되는 경우 **시계 방향** 으로 삼각형의 꼭 짓 점을 식별 합니다. 공간 표면 망상의 전면 (또는 외부)은 실제 세계 표면의 정면 (표시)와 일치 하는 것으로 간주 됩니다.

Surface 관찰자가 제공 하는 coarsest 삼각형 밀도가 여전히 불충분 인 경우에만 응용 프로그램에서 메시 단순화를 수행 해야 합니다 .이 작업은 계산 비용이 많이 들고 런타임에서 여러 제공 된 세부 정보 수준입니다.

각 표면 관찰자는 연결 되지 않은 여러 공간 표면을 제공할 수 있으므로 일부 응용 프로그램은 이러한 공간 노출 영역 메시를 서로 클리핑 한 다음 함께 zipper 수 있습니다. 일반적으로 주변 공간 표면 메시가 약간 겹치면 일반적으로 클리핑 단계가 필요 합니다.

## <a name="raycasting-and-collision"></a>Raycasting 및 충돌

물리 API (예: [Havok](http://www.havok.com/))가 공간 표면의 raycasting 및 충돌 기능을 제공 하는 응용 프로그램을 제공 하기 위해 응용 프로그램은 공간 노출 영역 메시를 물리학 API에 제공 해야 합니다. 물리학에 사용 되는 메시에는 종종 다음과 같은 속성이 있습니다.
* 적은 수의 삼각형만 포함 합니다. 물리 연산은 렌더링 작업 보다 계산 집약적입니다.
* ' 아주 좁게 '입니다. Solid로 설계 된 표면에는 작은 구멍이 없어야 합니다. 표시 될 수 있을 정도로 작은 구멍이 있어도 문제가 발생할 수 있습니다.
* 이는 볼록 hulls로 변환 됩니다. 볼록 hulls는 약간의 다각형이 있으며 구멍이 없는 것 이며 원시 삼각형 메시 보다 처리 하기에 훨씬 더 많은 계산을 제공 합니다.

공간 표면에 대해 raycasts를 수행 하는 경우 이러한 표면은 일반적으로 복잡 하 고 복잡 한 모양이 책상 처럼 복잡 한 세부 정보를 차지 합니다. 즉, 단일 raycast가 화면 모양에 대 한 충분 한 정보와 근처의 빈 공간 셰이프를 제공 하기에 충분 하지 않은 경우가 많습니다. 따라서 일반적으로 작은 영역 내에서 많은 raycasts를 수행 하 고 집계 결과를 사용 하 여 화면에 대 한 보다 안정적인 이해를 유도 하는 것이 좋습니다. 예를 들어, 화면에서 홀로그램 배치를 안내 하는 평균 10 개의 raycasts를 사용 하면 단일 raycasts를 사용 하는 훨씬 더 부드럽고 ' 떨림 ' 결과를 얻을 수 있습니다.

그러나 각 raycast에는 높은 계산 비용이 있을 수 있습니다. 따라서 사용 시나리오에 따라 공간 표면의 구멍을 매끄럽게 및 제거 하기 위해 [메시 처리](spatial-mapping.md#mesh-processing) 의 계산 비용에 대 한 추가 raycasts (모든 프레임 수행)의 계산 비용을 절충 해야 합니다 (공간을 사용 하는 경우 수행). 메시를 업데이트 합니다.

## <a name="troubleshooting"></a>문제 해결
* 표면 메시를 올바르게 지향 하려면 각 GameObject가 활성 상태 여야 메시를 생성 하기 위해 SurfaceObeserver에 전송 해야 합니다. 그렇지 않으면 메시는 공간에 표시 되지만 이상한 각도로 회전 됩니다.
* SurfaceObserver와 통신 하는 스크립트를 실행 하는 GameObject를 원본으로 설정 해야 합니다. 그렇지 않으면 사용자가 만들고 SurfaceObserver에 전송 하 여 메시를 생성 하는 모든 Gameobject 부모 게임 개체의 오프셋과 동일한 오프셋을 갖게 됩니다. 이렇게 하면 메시를 몇 미터 크게 표시 하 여 진행 상황을 디버그 하기가 매우 어려울 수 있습니다.

## <a name="see-also"></a>참조
* [좌표계](coordinate-systems.md)
* [DirectX의 공간 매핑](spatial-mapping-in-directx.md)
* [Unity의 공간 매핑](spatial-mapping-in-unity.md)
* [공간 매핑 디자인](spatial-mapping-design.md)
* [사례 연구 - 현실의 구멍 속 살펴보기](case-study-looking-through-holes-in-your-reality.md)
