---
title: 공간 매핑
description: 공간 매핑은 자세한는 HoloLens 주변 환경에서 실제 화면 표현을 제공합니다.
author: mattzmsft
ms.author: mazeller
ms.date: 03/21/2018
ms.topic: article
keywords: 공간 매핑, HoloLens, 혼합된 현실, 화면 재구성, 메시, sr
ms.openlocfilehash: 31abeca624512f1d5e721dbe879ca2243cf41345
ms.sourcegitcommit: 384b0087899cd835a3a965f75c6f6c607c9edd1b
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/12/2019
ms.locfileid: "59605042"
---
# <a name="spatial-mapping"></a><span data-ttu-id="4a9ec-104">공간 매핑</span><span class="sxs-lookup"><span data-stu-id="4a9ec-104">Spatial mapping</span></span>

<span data-ttu-id="4a9ec-105">공간 매핑은 개발자가 사실적인 혼합된 현실 환경을 만들 수 있도록 자세한 표현을 HoloLens, 주변 환경에서 실제 화면을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-105">Spatial mapping provides a detailed representation of real-world surfaces in the environment around the HoloLens, allowing developers to create a convincing mixed reality experience.</span></span> <span data-ttu-id="4a9ec-106">가상 환경으로 실제 환경에 병합 하 여 응용 프로그램에 실제 보일 홀로그램 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-106">By merging the real world with the virtual world, an application can make holograms seem real.</span></span> <span data-ttu-id="4a9ec-107">응용 프로그램 보다 자연스럽 게 맞출 수도 사용자의 기대치를 사용 하 여 친숙 한 실제 동작 및 상호 작용을 제공 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-107">Applications can also more naturally align with user expectations by providing familiar real-world behaviors and interactions.</span></span>

<br>

>[!VIDEO https://www.youtube.com/embed/zff2aQ1RaVo]

## <a name="device-support"></a><span data-ttu-id="4a9ec-108">장치 지원</span><span class="sxs-lookup"><span data-stu-id="4a9ec-108">Device support</span></span>

<table>
<tr>
<th><span data-ttu-id="4a9ec-109">기능</span><span class="sxs-lookup"><span data-stu-id="4a9ec-109">Feature</span></span></th><th style="width:150px"> <span data-ttu-id="4a9ec-110"><a href="hololens-hardware-details.md">HoloLens (첫 번째 범용)</a></span><span class="sxs-lookup"><span data-stu-id="4a9ec-110"><a href="hololens-hardware-details.md">HoloLens (1st gen)</a></span></span></th><th style="width:150px"><span data-ttu-id="4a9ec-111">HoloLens 2</span><span class="sxs-lookup"><span data-stu-id="4a9ec-111">HoloLens 2</span></span></th><th style="width:150px"> <span data-ttu-id="4a9ec-112"><a href="immersive-headset-hardware-details.md">몰입 형 헤드셋</a></span><span class="sxs-lookup"><span data-stu-id="4a9ec-112"><a href="immersive-headset-hardware-details.md">Immersive headsets</a></span></span></th>
</tr><tr>
<td> <span data-ttu-id="4a9ec-113">공간 매핑</span><span class="sxs-lookup"><span data-stu-id="4a9ec-113">Spatial mapping</span></span></td><td style="text-align: center;"> <span data-ttu-id="4a9ec-114">✔️</span><span class="sxs-lookup"><span data-stu-id="4a9ec-114">✔️</span></span></td><td style="text-align: center;"> <span data-ttu-id="4a9ec-115">✔️</span><span class="sxs-lookup"><span data-stu-id="4a9ec-115">✔️</span></span></td><td style="text-align: center;"></td>
</tr>
</table>



## <a name="conceptual-overview"></a><span data-ttu-id="4a9ec-116">개념적 개요</span><span class="sxs-lookup"><span data-stu-id="4a9ec-116">Conceptual overview</span></span>

<span data-ttu-id="4a9ec-117">![대화방을 다루는 표면 메시](images/SurfaceReconstruction.jpg)</span><span class="sxs-lookup"><span data-stu-id="4a9ec-117">![Mesh surfaces covering a room](images/SurfaceReconstruction.jpg)</span></span><br>
<span data-ttu-id="4a9ec-118">*대화방을 다루는 공간 매핑 메시의 예*</span><span class="sxs-lookup"><span data-stu-id="4a9ec-118">*An example of a spatial mapping mesh covering a room*</span></span>

<span data-ttu-id="4a9ec-119">두 기본 개체 공간 매핑에 사용 되는 형식은 ' 화면 공간 관찰자 ' 및 ' 공간 화면 '입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-119">The two primary object types used for spatial mapping are the 'Spatial Surface Observer' and the 'Spatial Surface'.</span></span>

<span data-ttu-id="4a9ec-120">응용 프로그램 공간 화면 관찰자에 게 하나 이상의 경계 볼륨의 공간이 있는 응용 프로그램 공간 매핑 데이터를 수신 하려는 영역을 정의 하는 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-120">The application provides the Spatial Surface Observer with one or more bounding volumes, to define the regions of space in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="4a9ec-121">이러한 볼륨 각각에 대 한 공간 매핑 화면 공간 집합을 사용 하 여 응용 프로그램을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-121">For each of these volumes, spatial mapping will provide the application with a set of Spatial Surfaces.</span></span>

<span data-ttu-id="4a9ec-122">이러한 볼륨 고정 (실제 관련 하 여 고정 된 위치) 또는 HoloLens (이동 있지만 회전 하지 않습니다는 HoloLens를 사용 하 여 환경에서 이동할 때)에 연결할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-122">These volumes may be stationary (in a fixed location with respect to the real world) or they may be attached to the HoloLens (they move, but do not rotate, with the HoloLens as it moves through the environment).</span></span> <span data-ttu-id="4a9ec-123">각 공간 화면 공간의 world 잠긴에 연결 된 삼각형 메시로 표현 작은 볼륨의 실제 화면 설명 [공간 좌표계](coordinate-systems.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-123">Each spatial surface describes real-world surfaces in a small volume of space, represented as a triangle mesh attached to a world-locked [spatial coordinate system](coordinate-systems.md).</span></span>

<span data-ttu-id="4a9ec-124">환경에 대 한 새 데이터를 수집 하는 HoloLens와 환경에 대 한 변경이 일어나는 경우 공간 화면 표시는 사라지고 변경 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-124">As the HoloLens gathers new data about the environment, and as changes to the environment occur, spatial surfaces will appear, disappear and change.</span></span>

## <a name="common-usage-scenarios"></a><span data-ttu-id="4a9ec-125">일반적인 사용 시나리오</span><span class="sxs-lookup"><span data-stu-id="4a9ec-125">Common usage scenarios</span></span>

![일반적인 공간 매핑 사용 시나리오의 예시: 배치, 폐색, 물리 및 탐색](images/sm-concepts-1000px.png)

### <a name="placement"></a><span data-ttu-id="4a9ec-127">배치</span><span class="sxs-lookup"><span data-stu-id="4a9ec-127">Placement</span></span>

<span data-ttu-id="4a9ec-128">사용자에 게 자연스럽 고 친숙 한 형태의 상호 작용을 제공 하는 기회와 함께 응용 프로그램을 제공 하는 공간 매핑 책상에 아래로 휴대폰을 배치 하는 보다 더 자연 스러운 있을까요?</span><span class="sxs-lookup"><span data-stu-id="4a9ec-128">Spatial mapping provides applications with the opportunity to present natural and familiar forms of interaction to the user; what could be more natural than placing your phone down on the desk?</span></span>

<span data-ttu-id="4a9ec-129">홀로그램의 배치를 제한 (또는 더 일반적으로 모든 공간 위치 선택) 화면으로 자연 매핑 3D (공간의 점)에서 2D (화면에서 지점)를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-129">Constraining the placement of holograms (or more generally, any selection of spatial locations) to lie on surfaces provides a natural mapping from 3D (point in space) to 2D (point on surface).</span></span> <span data-ttu-id="4a9ec-130">이렇게 하면 사용자 응용 프로그램에 제공 해야 하 고 있으므로 사용 하면 사용자의 상호 작용 빠르고 쉽고 보다 정밀 하 게 하는 정보의 양을 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-130">This reduces the amount of information the user needs to provide to the application and thus makes the user's interactions faster, easier and more precise.</span></span> <span data-ttu-id="4a9ec-131">이것이 특히 없기 때문에 '거리 만큼 떨어진'에서는 물리적 컴퓨터 또는 다른 사용자에 게 통신 하는 데 사용 되는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-131">This is particularly true because 'distance away' is not something that we are used to physically communicating to other people or to computers.</span></span> <span data-ttu-id="4a9ec-132">우리는 손가락을 사용 하 여 지점에 때 방향 있지만 거리 하지 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-132">When we point with our finger, we are specifying a direction but not a distance.</span></span>

<span data-ttu-id="4a9ec-133">주의 여기는 응용 프로그램 방향에서의 거리를 유추 하는 경우 (예를 들어 가장 가까운 찾으려는 사용자의 게이즈 방향 따라 raycast 수행 하 여 공간 화면),이 사용자는 안정적으로 예측할 수 있는 결과 생성 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-133">An important caveat here is that when an application infers distance from direction (for example by performing a raycast along the user's gaze direction to find the nearest spatial surface), this must yield results that the user is able to reliably predict.</span></span> <span data-ttu-id="4a9ec-134">그렇지 않으면 사용자 컨트롤에 대 한 손실 됩니다 하 고 불편 함을 느끼게 신속 하 게 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-134">Otherwise, the user will lose their sense of control and this can quickly become frustrating.</span></span> <span data-ttu-id="4a9ec-135">이 사용 하 여는 데 도움이 되는 한 가지 방법은 하나가 아닌 여러 raycasts에 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-135">One method that helps with this is to perform multiple raycasts instead of just one.</span></span> <span data-ttu-id="4a9ec-136">집계 결과 원활 하 고 예측 가능성이 더욱 뛰어난 (광선 작은 구멍을 통해 전달 하거나 사용자의 인식 되지 않는 기 하 도형의 약간에 도달 하 여 발생할 수 있습니다) 처럼 일시적인 '이상 값' 결과에서 영향을 줄 가능성이 적습니다 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-136">The aggregate results should be smoother and more predictable, less susceptible to influence from transient 'outlier' results (as can be caused by rays passing through tiny holes or hitting small bits of geometry that the user is not aware of).</span></span> <span data-ttu-id="4a9ec-137">집계 하거나 다듬으면 수행할 수도 있습니다 시간별; 예를 들어 사용자 로부터 거리에서 다를 수 있습니다를 홀로그램 삽입할 최대 속도 제한할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-137">Aggregation or smoothing can also be performed over time; for example you can limit the maximum speed at which a hologram can vary in distance from the user.</span></span> <span data-ttu-id="4a9ec-138">최소 및 최대 거리 값을 단순히 제한 유용할 수 있습니다, 이동할 홀로그램 귀여운 거리에 갑자기 되지 않거나 충돌 하는 사용자의 얼굴에 다시 제공 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-138">Simply limiting the minimum and maximum distance value can also help, so the hologram being moved does not suddenly fly away into the distance or come crashing back into the user's face.</span></span>

<span data-ttu-id="4a9ec-139">응용 프로그램 가이드 홀로그램 배치 형태와 화면 방향을 사용 되는 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-139">Applications can also use the shape and direction of surfaces to guide hologram placement.</span></span> <span data-ttu-id="4a9ec-140">Holographic chair 벽 통해 침투 하지 해야 하 고 약간도 없는 경우에 밑으로 플러시 배치 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-140">A holographic chair should not penetrate through walls and should sit flush with the floor even if it is slightly uneven.</span></span> <span data-ttu-id="4a9ec-141">그러나 이러한 종류의 기능은 단순히 raycasts, 비슷한 문제를 적용할 것이 아니라 물리학 충돌의 사용 가능성이 의존 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-141">This kind of functionality would likely rely upon the use of physics collisions rather than just raycasts, however similar concerns will apply.</span></span> <span data-ttu-id="4a9ec-142">배치 홀로그램은 다리를의 자에 같은 튀어나온 많은 작은 다각형 있으면 더 하지 않고 공간 표면 위에 슬라이드 할 수 있도록 이러한 다각형 물리학 표현을 너비와 높이 원활 하 게 수행할 것으로 확장 적합할 수 있습니다. 수월한 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-142">If the hologram being placed has many small polygons that stick out, like the legs on a chair, it may make sense to expand the physics representation of those polygons to something wider and smoother so that they are more able to slide over spatial surfaces without snagging.</span></span>

<span data-ttu-id="4a9ec-143">으로 치 우 치면 해당 사용자 입력 완전히에 지금 단순화할 수 있습니다. 및 화면 공간을 완전히 자동 홀로그램 배치 하는 데 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-143">At its extreme, user input can be simplified away entirely and spatial surfaces can be used to perform entirely automatic hologram placement.</span></span> <span data-ttu-id="4a9ec-144">예를 들어, 응용 프로그램 수 놓고 조명 스위치를 holographic 사용자 키를 누를 벽에 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-144">For example, the application could place a holographic light-switch somewhere on the wall for the user to press.</span></span> <span data-ttu-id="4a9ec-145">예측에 대 한 동일한 주의 사항이 적용 이중; 여기 응용 프로그램 설정 하지 않으며 항상 홀로그램 (조명 스위치를 사용자에 연결할 수 없는 위치에 표시) 하는 경우 예상 되는 사용자가 홀로그램 배치에 대 한 제어 하지만 않으면이 됩니다 환경입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-145">The same caveat about predictability applies doubly here; if the user expects control over hologram placement, but the application does not always place holograms where they expect (if the light-switch appears somewhere that the user cannot reach), then this will be a frustrating experience.</span></span> <span data-ttu-id="4a9ec-146">사용자 수정 해야 하는 자동 배치 하는 데 성능은 낮을 수 실제로 일부에 필요 하는 데 항상 배치, 사용자 보다 자동 배치를 성공적으로 이므로 *예상*, 수동 수정 부담 찾기란!</span><span class="sxs-lookup"><span data-stu-id="4a9ec-146">It can actually be worse to perform automatic placement that requires user correction some of the time, than to just require the user to always perform placement themselves; because successful automatic placement is *expected*, manual correction feels like a burden!</span></span>

<span data-ttu-id="4a9ec-147">또한 배치는 응용 프로그램에 따라 달라 집니다 화면 공간을 사용 하도록 응용 프로그램의 기능 [환경을 검색](spatial-mapping-design.md#the-environment-scanning-experience)합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-147">Note also that the ability of an application to use spatial surfaces for placement depends heavily on the application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience).</span></span> <span data-ttu-id="4a9ec-148">화면을를 검색 하지 않은 경우 다음 사용할 수 없습니다 배치 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-148">If a surface has not been scanned, then it cannot be used for placement.</span></span> <span data-ttu-id="4a9ec-149">것은 분명히이 사용자에 게 새로운 화면을 검색 하거나 새 위치를 선택 하거나 시키는 되도록 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-149">It is up to the application to make this clear to the user, so that they can either help scan new surfaces or select a new location.</span></span>

<span data-ttu-id="4a9ec-150">사용자에 게 시각적 피드백은 배치 중 매우 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-150">Visual feedback to the user is of paramount importance during placement.</span></span> <span data-ttu-id="4a9ec-151">사용자가 위치를 알고 있는 홀로그램으로 가장 가까운 화면을 기준으로 해야 [효과 토대가](spatial-mapping.md#visualization)합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-151">The user needs to know where the hologram is in relation to the nearest surface with [grounding effects](spatial-mapping.md#visualization).</span></span> <span data-ttu-id="4a9ec-152">있습니다 (예를 들어 화면 근처에 있는 다른 충돌)로 인해 해당 홀로그램 이동을 제약 되는 이유를 이해 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-152">They should understand why the movement of their hologram is being constrained (for example, due to collision with another nearby surface).</span></span> <span data-ttu-id="4a9ec-153">현재 위치에서를 홀로그램을 가져올 수 없으면 해당, 다음 시각적 피드백 해야 하지 않는 이유 명확 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-153">If they cannot place a hologram in the current location, then visual feedback should make it clear why not.</span></span> <span data-ttu-id="4a9ec-154">예를 들어, 배치 하는 사용자가 시도 하는 경우 holographic couch 걸려 절반 정도 벽에 벽 뒤에 있는 소파 부분을 화난 색에 이렇게 해야 다음 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-154">For example, if the user is trying to place a holographic couch stuck half-way into the wall, then the portions of the couch that are behind the wall should pulsate in an angry color.</span></span> <span data-ttu-id="4a9ec-155">또는 반대로 응용 프로그램 공간 화면 사용자는 실제 화면을 볼 수 있는 위치를 찾을 수 없으면 다음 응용 프로그램 해야이 선택을 취소 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-155">Or conversely, if the application cannot find a spatial surface in a location where the user can see a real-world surface, then the application should make this clear.</span></span> <span data-ttu-id="4a9ec-156">이 영역의 접지 효과의 명확한 없을 경우가이 작업을 수행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-156">The obvious absence of a grounding effect in this area may achieve this purpose.</span></span>

### <a name="occlusion"></a><span data-ttu-id="4a9ec-157">폐색</span><span class="sxs-lookup"><span data-stu-id="4a9ec-157">Occlusion</span></span>

<span data-ttu-id="4a9ec-158">공간 매핑 화면의 주요 용도 중 하나를 홀로그램 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-158">One of the primary uses of spatial mapping surfaces is simply to occlude holograms.</span></span> <span data-ttu-id="4a9ec-159">이 간단한 동작 홀로그램, 사용자와 동일한 물리적 공간을 실제로 산재 비서 럴 의미를 만드는 데 있어의 인식된 현실성에 큰 영향을 미칩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-159">This simple behavior has a huge impact on the perceived realism of holograms, helping to create a visceral sense that really inhabit the same physical space as the user.</span></span>

<span data-ttu-id="4a9ec-160">또한 폐색 사용자에 게 정보를 제공 홀로그램은 실제 화면에서 폐색 수에 표시 되 면 해당 홀로그램 환경에서의 공간 위치에 대 한 추가 시각적 피드백을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-160">Occlusion also provides information to the user; when a hologram appears to be occluded by a real-world surface, this provides additional visual feedback as to the spatial location of that hologram in the world.</span></span> <span data-ttu-id="4a9ec-161">반대로, 폐색 수도 유용 하 게 *숨기기* 직관적인 방법으로 더 단순하게 visual 벽 수 뒤 occluding 홀로그램; 사용자의 정보입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-161">Conversely, occlusion can also usefully *hide* information from the user; occluding holograms behind walls can reduce visual clutter in an intuitive way.</span></span> <span data-ttu-id="4a9ec-162">숨기 거 나 표시를 홀로그램, 사용자는 단순히 해당 헤드 이동할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-162">To hide or reveal a hologram, the user merely has to move their head.</span></span>

<span data-ttu-id="4a9ec-163">폐색 친숙 한 물리적 상호 작용;에 따라 자연 스러운 사용자 인터페이스에 대 한 기대를 사용할 수도 있습니다. 해당 화면을 이므로 화면에서를 홀로그램 폐색 됩니다, 경우 사용자는 예상를 홀로그램을 *충돌* 를 노출 하 고 단순히 통과 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-163">Occlusion can also be used to prime expectations for a natural user interface based upon familiar physical interactions; if a hologram is occluded by a surface it is because that surface is solid, so the user should expect that the hologram will *collide* with that surface and not simply pass through it.</span></span>

<span data-ttu-id="4a9ec-164">경우에 따라 홀로그램의 폐색 바람직하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-164">Sometimes, occlusion of holograms is undesirable.</span></span> <span data-ttu-id="4a9ec-165">사용자를 홀로그램으로 상호 작용할 수 있게 하는 경우 다음 필요할 실제 화면 뒤 하는 경우에 볼 수 없겠죠-되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-165">If a user needs to be able to interact with a hologram, then they need to be able to see it - even if it is behind a real-world surface.</span></span> <span data-ttu-id="4a9ec-166">이러한 경우에 일반적으로 것이 좋습니다 (예를 들어, 밝기를 줄여 해당) 폐색 되 면 이러한를 홀로그램 다르게 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-166">In such cases, it usually makes sense to render such a hologram differently when it is occluded (for example, by reducing its brightness).</span></span> <span data-ttu-id="4a9ec-167">이 이렇게 하면 사용자가 시각적으로 찾을 수는 홀로그램 하지만 뭔가 계속 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-167">This way, the user will be able to visually locate the hologram, but they will still be aware that it is behind something.</span></span>

### <a name="physics"></a><span data-ttu-id="4a9ec-168">물리학</span><span class="sxs-lookup"><span data-stu-id="4a9ec-168">Physics</span></span>

<span data-ttu-id="4a9ec-169">물리학 시뮬레이션의 사용은 또 다른 방법에 공간 매핑을 사용 하 여 강화할 수 있습니다는 *존재* 의 사용자의 물리적 공간에 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-169">The use of physics simulation is another way in which spatial mapping can be used to reinforce the *presence* of holograms in the user's physical space.</span></span> <span data-ttu-id="4a9ec-170">내 holographic 고무 공 책상 해제 현실적으로 롤업 하 고, 바닥에서 바운스, 소파에서 사라집니다을 아닌지 사실상 믿기 어려울 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-170">When my holographic rubber ball rolls realistically off my desk, bounces across the floor and disappears under the couch, it might be hard for me to believe that it's not really there.</span></span>

<span data-ttu-id="4a9ec-171">또한 물리학 시뮬레이션 자연스럽 고 친숙 한 물리학 기반 상호 작용을 사용 하도록 응용 프로그램에 대 한 영업 기회를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-171">Physics simulation also provides the opportunity for an application to use natural and familiar physics-based interactions.</span></span> <span data-ttu-id="4a9ec-172">현장에서 부분 주위 holographic 가구 이동 가능성이 됩니다 사용자가 보다 쉽게 가구 적절 한 관성와 마찰 floor에서 상대 (sliding) 된 것 처럼 응답 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-172">Moving a piece of holographic furniture around on the floor will likely be easier for the user if the furniture responds as if it were sliding across the floor with the appropriate inertia and friction.</span></span>

<span data-ttu-id="4a9ec-173">현실적인 실제 동작을 생성 하기 위해 가능성이 해야 일부를 수행할 [처리 메시](spatial-mapping.md#mesh-processing) 제거 hallucinations 부동 및 다듬기 대략적인 화면 구멍을 채운 등입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-173">In order to generate realistic physical behaviors, you will likely need to perform some [mesh processing](spatial-mapping.md#mesh-processing) such as filling holes, removing floating hallucinations and smoothing rough surfaces.</span></span>

<span data-ttu-id="4a9ec-174">고려를 해야 하는 방법을 응용 프로그램 [환경을 검색](spatial-mapping-design.md#the-environment-scanning-experience) 물리학 시뮬레이션에 영향을 줍니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-174">You will also need to consider how your application's [scanning experience](spatial-mapping-design.md#the-environment-scanning-experience) influences its physics simulation.</span></span> <span data-ttu-id="4a9ec-175">첫째, 요소와 충돌 하지 않습니다 화면 누락 알려진된 전 세계의 최종 끄고 복도 아래로 고무 공을 해제 롤오버 될 때 어떻게 되나요?</span><span class="sxs-lookup"><span data-stu-id="4a9ec-175">Firstly, missing surfaces won't collide with anything; what happens when the rubber ball rolls off down the corridor and off the end of the known world?</span></span> <span data-ttu-id="4a9ec-176">둘째, 시간이 지남에 따라 환경의 변경 내용에 응답할를 계속할지 여부를 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-176">Secondly, you need to decide whether you will continue to respond to changes in the environment over time.</span></span> <span data-ttu-id="4a9ec-177">일부 경우에는 응답 하려는 빨리; 사용자 문 및 가구를 사용 하는 들어오는 Roman 화살표 템 방어에서 이동 가능한 barricades로 하는 경우를 가정해 보겠습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-177">In some cases, you will want to respond as quickly as possible; say if the user is using doors and furniture as movable barricades in defense against a tempest of incoming Roman arrows.</span></span> <span data-ttu-id="4a9ec-178">다른 경우에서 그러나 하려는 새 업데이트를 무시 합니다. 사용자 층에는 트랙 주위에 holographic 스포츠카 운전 갑자기 아닐 친구도 애견 트랙 중간 배치 하기로 한 경우.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-178">In other cases though, you may want to ignore new updates; driving your holographic sports car around the racetrack on your floor may suddenly not be so fun if your dog decides to sit in the middle of the track.</span></span>

### <a name="navigation"></a><span data-ttu-id="4a9ec-179">탐색</span><span class="sxs-lookup"><span data-stu-id="4a9ec-179">Navigation</span></span>

<span data-ttu-id="4a9ec-180">응용 프로그램 공간 매핑 데이터를 사용 하 여 holographic 문자 (또는 에이전트) 실제 사용자는 동일한 방식으로 실제 이동 기능을 부여할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-180">Applications can use spatial mapping data to grant holographic characters (or agents) the ability to navigate the real world in the same way a real person would.</span></span> <span data-ttu-id="4a9ec-181">사용자 및 친구 들과 자연스럽 고 친숙 한 동작의 동일한 집합에이 제한 하 여 holographic 문자의 존재를 보강 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-181">This can help reinforce the presence of holographic characters by restricting them to the same set of natural, familiar behaviors as those of the user and their friends.</span></span>

<span data-ttu-id="4a9ec-182">탐색 기능으로 사용자에 게 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-182">Navigation capabilities could be useful to users as well.</span></span> <span data-ttu-id="4a9ec-183">지정된 된 영역에서 탐색 지도 빌드한 후 해당 위치를 사용 하 여 알 수 없는 새 사용자에 대 한 holographic 지침을 제공 하기 공유할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-183">Once a navigation map has been built in a given area, it could be shared to provide holographic directions for new users unfamiliar with that location.</span></span> <span data-ttu-id="4a9ec-184">이 맵은 평범 '' 흐르는 트래픽을 원활 하 게 유지할 수 또는 생성 사이트와 같은 위험한 위치에는 사고 방지를 위해 설계할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-184">This map could be designed to help keep pedestrian 'traffic' flowing smoothly, or to avoid accidents in dangerous locations like construction sites.</span></span>

<span data-ttu-id="4a9ec-185">탐색 기능을 구현에 관련 된 핵심 기술 과제 움직일 수 화면 (사용자 테이블에서 설명 하지 않습니다!) 및 (닫힌된 문을 통해 사람 서둘러!) 환경의 변화를 정상적으로 적응 신뢰할 수 있는 검색 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-185">The key technical challenges involved in implementing navigation functionality will be reliable detection of walkable surfaces (humans don't walk on tables!) and graceful adaptation to changes in the environment (humans don't walk through closed doors!).</span></span> <span data-ttu-id="4a9ec-186">일부 메시 필요할 수 있습니다 [처리](spatial-mapping.md#mesh-processing) 경로 계획 하 고 가상 문자로 탐색 하기 전에 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-186">The mesh may require some [processing](spatial-mapping.md#mesh-processing) before it is usable for path-planning and navigation by a virtual character.</span></span> <span data-ttu-id="4a9ec-187">메시 다듬기 및 hallucinations 제거 문자 중단 되는 것을 방지 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-187">Smoothing the mesh and removing hallucinations may help avoid characters becoming stuck.</span></span> <span data-ttu-id="4a9ec-188">플레이어의 경로 계획 및 탐색 계산 속도 높이기 위해 메시를 크게 간소화 하려면.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-188">You may also wish to drastically simplify the mesh in order to speed up your character's path-planning and navigation calculations.</span></span> <span data-ttu-id="4a9ec-189">이러한 항목에 사용 가능한 연구 문헌의 풍부한를 이러한 과제 비디오 게임기 기술의 개발 세심 한 주의가 수령 했으며.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-189">These challenges have received a great deal of attention in the development of videogame technology, and there is a wealth of available research literature on these topics.</span></span>

<span data-ttu-id="4a9ec-190">참고는 Unity의 기본 제공 NavMesh 기능 공간 매핑 화면을 사용 하 여 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-190">Note that the built-in NavMesh functionality in Unity cannot be used with spatial mapping surfaces.</span></span> <span data-ttu-id="4a9ec-191">응용 프로그램까지 공간 매핑 화면을 알 수 없는 때문에 이것이 NavMesh 데이터 파일을 원본 자산 미리 생성 해야 하는 반면 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-191">This is because spatial mapping surfaces are not known until the application starts, whereas NavMesh data files need to be generated from source assets ahead of time.</span></span> <span data-ttu-id="4a9ec-192">참고, 공간 매핑 시스템 제공 하지 것입니다 [표면 매우 멀리 떨어진 곳에 대 한 내용은](spatial-mapping-design.md#the-environment-scanning-experience) 사용자의 현재 위치에서.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-192">Also note that, the spatial mapping system will not provide [information about surfaces very far away](spatial-mapping-design.md#the-environment-scanning-experience) from the user's current location.</span></span> <span data-ttu-id="4a9ec-193">따라서 응용 프로그램 ' 해야 합니다 ' 표면 자체는 매우 큰 영역 맵을 작성 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-193">So the application must 'remember' surfaces itself if it is to build a map of a very large area.</span></span>

### <a name="visualization"></a><span data-ttu-id="4a9ec-194">시각화</span><span class="sxs-lookup"><span data-stu-id="4a9ec-194">Visualization</span></span>

<span data-ttu-id="4a9ec-195">표시 되지 공간 표면에 적절 한 것이 대부분의 시간 시각적인 혼란을 최소화 하는 실시간 자체 세계가 말하십시오.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-195">Most of the time it is appropriate for spatial surfaces to be invisible; to minimize visual clutter and let the real world speak for itself.</span></span> <span data-ttu-id="4a9ec-196">그러나 때로는 것 실제 대응 표시 되어 있지만 직접 공간 매핑 화면을 시각화 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-196">However, sometimes it is useful to visualize spatial mapping surfaces directly, despite the fact that their real-world counterparts are already visible.</span></span>

<span data-ttu-id="4a9ec-197">사용자가 (배치 holographic 캐비닛을 벽에 예를 들어) 화면으로 홀로그램을 시도할 경우에 예를 들어를 홀로그램을 화면에 섀도 캐스팅 하 여 '포함' 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-197">For example, when the user is trying to place a hologram onto a surface (placing a holographic cabinet on the wall, say) it can be useful to 'ground' the hologram by casting a shadow onto the surface.</span></span> <span data-ttu-id="4a9ec-198">이 통해 사용자는를 홀로그램 및 화면 간 정확한 실제 근접성을 훨씬 더 명확 하 게 파악할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-198">This gives the user a much clearer sense of the exact physical proximity between the hologram and the surface.</span></span> <span data-ttu-id="4a9ec-199">시각적으로 '미리 보기 의' 변경 된 사용자를 커밋하기 전에 보다 일반적인 방법의 예로 이기도 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-199">This is also an example of the more general practice of visually 'previewing' a change before the user commits to it.</span></span>

<span data-ttu-id="4a9ec-200">화면을 시각화 하 여 응용 프로그램은 이해 환경의 사용자와 공유할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-200">By visualizing surfaces, the application can share with the user its understanding of the environment.</span></span> <span data-ttu-id="4a9ec-201">예를 들어, holographic 보드 게임 사용자 상호 작용 하는 이동 해야 알 수 있도록 '테이블과' 식별 하는 가로 화면을 시각화할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-201">For example, a holographic board game could visualize the horizontal surfaces that it has identified as 'tables', so the user knows where they should go to interact.</span></span>

<span data-ttu-id="4a9ec-202">시각화 화면 공간 보기에서 숨겨져 있는 주변 사용자를 표시 하는 유용한 방법 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-202">Visualizing surfaces can be a useful way to show the user nearby spaces that are hidden from view.</span></span> <span data-ttu-id="4a9ec-203">해당 거실에서 해당 주방 (및 모든 해당 포함 된 홀로그램)에 대 한 사용자 액세스를 제공 하는 간단한 방법을 제공할 수이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-203">This could provide a simple way to give the user access to their kitchen (and all of its contained holograms) from their living room.</span></span>

<span data-ttu-id="4a9ec-204">공간 매핑 제공한 표면 메시는 특히 '정리' 일 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-204">The surface meshes provided by spatial mapping may not be particularly 'clean'.</span></span> <span data-ttu-id="4a9ec-205">따라서 이것을 적절 하 게 시각화할 것입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-205">Thus it is important to visualize them appropriately.</span></span> <span data-ttu-id="4a9ec-206">일반적인 조명 계산 '정리' 질감이 표면에 투영 되는 좀 더 깔끔하게 모양을 제공할 도움이 될 수 있습니다 하는 동안 표면 법선의 오류를 시각적으로 불필요 한 시간 내에 드러날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-206">Traditional lighting calculations may highlight errors in surface normals in a visually distracting manner, whilst 'clean' textures projected onto the surface may help to give it a tidier appearance.</span></span> <span data-ttu-id="4a9ec-207">수행할 수 이기도 [처리 메시](spatial-mapping.md#mesh-processing) 표면 렌더링 되기 전에 메시 속성을 개선 하기 위해.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-207">It is also possible to perform [mesh processing](spatial-mapping.md#mesh-processing) to improve mesh properties, before the surfaces are rendered.</span></span>

## <a name="using-the-surface-observer"></a><span data-ttu-id="4a9ec-208">Surface 관찰자를 사용 하 여</span><span class="sxs-lookup"><span data-stu-id="4a9ec-208">Using The Surface Observer</span></span>

<span data-ttu-id="4a9ec-209">공간 매핑에 대 한 시작점은 노출 관찰자입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-209">The starting point for spatial mapping is the surface observer.</span></span> <span data-ttu-id="4a9ec-210">프로그램 흐름은 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-210">Program flow is as follows:</span></span>
* <span data-ttu-id="4a9ec-211">Surface observer 개체 만들기</span><span class="sxs-lookup"><span data-stu-id="4a9ec-211">Create a surface observer object</span></span>
   * <span data-ttu-id="4a9ec-212">응용 프로그램 공간 매핑 데이터를 수신 하려는 관심 영역을 정의 하려면 하나 이상의 공간 볼륨을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-212">Provide one or more spatial volumes, to define the regions of interest in which the application wishes to receive spatial mapping data.</span></span> <span data-ttu-id="4a9ec-213">공간 볼륨은 구 또는 상자와 같은 공간 영역을 정의 셰이프 하기만 하면 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-213">A spatial volume is simply a shape defining a region of space, such as a sphere or a box.</span></span>
   * <span data-ttu-id="4a9ec-214">공간 볼륨 물리적 세계의 고정된 된 영역을 식별 하는 전 세계 잠긴 공간 좌표계를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-214">Use a spatial volume with a world-locked spatial coordinate system to identify a fixed region of the physical world.</span></span>
   * <span data-ttu-id="4a9ec-215">업데이트 된 공간 볼륨을 각 프레임 본문 잠긴 공간 좌표계 영역 이동 (하지만 회전 하지 않습니다)는 공간을 식별 하기를 사용 하 여 사용자를 사용 하 여 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-215">Use a spatial volume, updated each frame with a body-locked spatial coordinate system, to identify a region of space that moves (but does not rotate) with the user.</span></span>
   * <span data-ttu-id="4a9ec-216">이러한 공간 볼륨은 나중에 언제 든 변경 하는 사용자 또는 응용 프로그램의 상태를 변경할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-216">These spatial volumes may be changed later at any time, as the status of the application or the user changes.</span></span>
* <span data-ttu-id="4a9ec-217">사용 하 여 폴링 또는 화면 공간에 대 한 정보를 검색 하는 알림</span><span class="sxs-lookup"><span data-stu-id="4a9ec-217">Use polling or notification to retrieve information about spatial surfaces</span></span>
   * <span data-ttu-id="4a9ec-218">있습니다 폴링할 수 있는 '' 공간 표면 상태에 대 한 노출 observer 언제 든 지 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-218">You may 'poll' the surface observer for spatial surface status at any time.</span></span> <span data-ttu-id="4a9ec-219">또는 노출 관찰자의 화면 변경 이벤트에 대 한 공간 표면 변경 된 경우 응용 프로그램 알려 등록할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-219">Alternatively, you may register for the surface observer's 'surfaces changed' event, which will notify the application when spatial surfaces have changed.</span></span>
   * <span data-ttu-id="4a9ec-220">하면 보기 프러스텀 같은 동적 공간 볼륨 또는 본문 잠긴 볼륨에 대 한 관심 영역을 설정 하 고 공간 표면의 현재 집합을 구한 다음 각 프레임을 변경을 위한 폴링을 응용 프로그램 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-220">For a dynamic spatial volume, such as the view frustum, or a body-locked volume, applications will need to poll for changes each frame by setting the region of interest and then obtaining the current set of spatial surfaces.</span></span>
   * <span data-ttu-id="4a9ec-221">단일 객실을 포함 하는 전 세계 잠긴 큐브와 같은 고정 볼륨에 대 한 응용 프로그램 내에 해당 볼륨에서 공간 표면 변경한 경우 알림을 받으려면 화면 변경 이벤트에 대 한 등록이 가능 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-221">For a static volume, such as a world-locked cube covering a single room, applications may register for the 'surfaces changed' event to be notified when spatial surfaces inside that volume may have changed.</span></span>
* <span data-ttu-id="4a9ec-222">프로세스 변경 내용 표시</span><span class="sxs-lookup"><span data-stu-id="4a9ec-222">Process surfaces changes</span></span>
   * <span data-ttu-id="4a9ec-223">제공 된 공간 화면 집합을 반복 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-223">Iterate the provided set of spatial surfaces.</span></span>
   * <span data-ttu-id="4a9ec-224">공간 서피스 추가, 변경 또는 제거를 분류 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-224">Classify spatial surfaces as added, changed or removed.</span></span>
   * <span data-ttu-id="4a9ec-225">해당 하는 경우 각 추가 되거나 변경 된 공간 화면에서에 대 한 원하는 수준의 세부 정보 화면의 현재 상태를 나타내는 업데이트 된 메시를 수신 하는 비동기 요청을 제출 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-225">For each added or changed spatial surface, if appropriate submit an asynchronous request to receive updated mesh representing the surface's current state at the desired level of detail.</span></span>
* <span data-ttu-id="4a9ec-226">비동기 메시 요청 (다음 섹션에서 자세한 정보)을 처리 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-226">Process the asynchronous mesh request (more details in following sections).</span></span>

## <a name="mesh-caching"></a><span data-ttu-id="4a9ec-227">캐싱 메시</span><span class="sxs-lookup"><span data-stu-id="4a9ec-227">Mesh Caching</span></span>

<span data-ttu-id="4a9ec-228">공간 화면 밀도 삼각형 메시 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-228">Spatial surfaces are represented by dense triangle meshes.</span></span> <span data-ttu-id="4a9ec-229">저장, 렌더링 및 이러한 메시는 처리에 많은 계산 및 저장소 리소스를 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-229">Storing, rendering and processing these meshes can consume significant computational and storage resources.</span></span> <span data-ttu-id="4a9ec-230">따라서 각 응용 프로그램에 캐싱 구성표 메시 처리 및 저장을 사용 하는 리소스를 최소화 하기 위해 해당 요구 사항에 맞게 적절 한 메시를 채택 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-230">As such, each application should adopt a mesh caching scheme appropriate to its needs, in order to minimize the resources used for mesh processing and storage.</span></span> <span data-ttu-id="4a9ec-231">이 체계는 유지 하는 메시 및 취소를 할 뿐만 아니라 공간 각 화면에 대 한 메시의 업데이트 시기를 결정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-231">This scheme should determine which meshes to retain and which to discard, as well as when to update the mesh for each spatial surface.</span></span>

<span data-ttu-id="4a9ec-232">많은 논의 고려 사항을 직접 알려줍니다 어떻게 메시 캐싱 응용 프로그램에 접근 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-232">Many of the considerations discussed there will directly inform how your application should approach mesh caching.</span></span> <span data-ttu-id="4a9ec-233">사용자 환경을 통해 이동 하는 방법, 노출 하는 데 필요한, 다양 한 표면을 관찰 하는 경우 및 환경에서 변경 내용을 캡처할 때 고려해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-233">You should consider how the user moves through the environment, which surfaces are needed, when different surfaces will be observed and when changes in the environment should be captured.</span></span>

<span data-ttu-id="4a9ec-234">Surface 관찰자를 제공한 화면 변경 이벤트를 해석 하는 경우 기본 메시 캐싱 논리는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-234">When interpreting the 'surfaces changed' event provided by the surface observer, the basic mesh caching logic is as follows:</span></span>
* <span data-ttu-id="4a9ec-235">전에 없었던 공간 표면 ID를을 인식 하는 응용 프로그램 공간 새 화면으로이 처리 해야 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-235">If the application sees a spatial surface ID that it has not seen before, it should treat this as a new spatial surface.</span></span>
* <span data-ttu-id="4a9ec-236">응용 프로그램을 알려진된 ID 사용 하 여 공간 화면 표시 되지만 새 업데이트 시간을 사용 하 여 처리 하는이 업데이트는 공간 화면.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-236">If the application sees a spatial surface with a known ID but with a new update time, it should treat this as an updated spatial surface.</span></span>
* <span data-ttu-id="4a9ec-237">응용 프로그램에서 더 이상 알려진된 ID 사용 하 여 공간 화면을 인식 하는 경우 공간 제거 화면으로이 처리 해야 하 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-237">If the application no longer sees a spatial surface with a known ID, it should treat this as a removed spatial surface.</span></span>

<span data-ttu-id="4a9ec-238">다음과 같이 선택 작업을 수행 할 각 응용 프로그램까지 것:</span><span class="sxs-lookup"><span data-stu-id="4a9ec-238">It is up to each application to then make the following choices:</span></span>
* <span data-ttu-id="4a9ec-239">새로운 공간 화면에 대 한 메시 요청할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="4a9ec-239">For new spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="4a9ec-240">일반적으로 메시 사용자에 게 유용한 새 정보를 제공할 수 있는 새 공간 표면에 즉시 요청 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-240">Generally mesh should be requested immediately for new spatial surfaces, which may provide useful new information to the user.</span></span>
   * <span data-ttu-id="4a9ec-241">그러나 거의 및 사용자 앞에 새 공간 표면 우선 순위를 지정 해야 하 고 해당 메시 처음 요청할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-241">However, new spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="4a9ec-242">예를 들어 응용 프로그램에 영구 또는 임시적으로 '고정' 환경의 모델의 경우 새 메시에 필요 하지 않은, 경우 다음이 요청 해야 할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-242">If the new mesh is not needed, if for example the application has permanently or temporarily 'frozen' its model of the environment, then it should not be requested.</span></span>
* <span data-ttu-id="4a9ec-243">업데이트 된 공간 표면의 대 한 메시 요청할 수 있습니까?</span><span class="sxs-lookup"><span data-stu-id="4a9ec-243">For updated spatial surfaces, should mesh be requested?</span></span>
   * <span data-ttu-id="4a9ec-244">거의 및 사용자 앞에 업데이트 된 공간 표면 우선 순위를 지정 해야 하 고 해당 메시 먼저 요청 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-244">Updated spatial surfaces near and in front of the user should be given priority and their mesh should be requested first.</span></span>
   * <span data-ttu-id="4a9ec-245">또한 검색 경험 중 특히 업데이트 표면의 보다 새로운 화면에 더 높은 우선 순위를 지정 하는 적절 한 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-245">It may also be appropriate to give higher priority to new surfaces than to updated surfaces, especially during the scanning experience.</span></span>
   * <span data-ttu-id="4a9ec-246">처리 비용을 최소화 하려면 응용 프로그램 공간 표면에 대 한 업데이트를 처리 하는 속도 제한 할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-246">To limit processing costs, applications may wish to throttle the rate at which they process updates to spatial surfaces.</span></span>
   * <span data-ttu-id="4a9ec-247">공간 화면에 변경 내용을 부 버전, 예를 들어 화면의 경계는 작은 경우에 업데이트 프로세스에 충분 한 중요할 수 있습니다는 유추할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-247">It may be possible to infer that changes to a spatial surface are minor, for example if the bounds of the surface are small, in which case the update may not be important enough to process.</span></span>
   * <span data-ttu-id="4a9ec-248">현재 사용자의 관심 영역 외부 공간 표면에 대 한 업데이트 수는 없지만 경우 노출 관찰자 사용에서 공간 경계 볼륨을 수정 하는 것이 효율적 완전히 무시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-248">Updates to spatial surfaces outside the current region of interest of the user may be ignored entirely, though in this case it may be more efficient to modify the spatial bounding volumes in use by the surface observer.</span></span>
* <span data-ttu-id="4a9ec-249">공간 표면의 제거에 대 한 메시를 삭제 해야?</span><span class="sxs-lookup"><span data-stu-id="4a9ec-249">For removed spatial surfaces, should mesh be discarded?</span></span>
   * <span data-ttu-id="4a9ec-250">일반적으로 메시를 삭제 해야 즉시 공간 표면 제거에 홀로그램 폐색을 올바른 상태로 유지 되도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-250">Generally mesh should be discarded immediately for removed spatial surfaces, so that hologram occlusion remains correct.</span></span>
   * <span data-ttu-id="4a9ec-251">그러나 응용 프로그램에는 생각 하는 경우 공간 화면 나타납니다 곧 (아마도 따라 사용자 환경의 설계), 다음에 해당 메시를 삭제 하 고 나중에 다시 다시 보다 유지 하려면 더 효율적일 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-251">However, if the application has reason to believe that a spatial surface will reappear shortly (perhaps based upon the design of the user experience), then it may be more efficient to retain it than to discard its mesh and recreate it again later.</span></span>
   * <span data-ttu-id="4a9ec-252">응용 프로그램은 사용자 환경의 대규모 모델을 작성 하는 경우 다음이 하지 않으려는 모든 메시를 전혀 삭제 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-252">If the application is building a large-scale model of the user's environment then it may not wish to discard any meshes at all.</span></span> <span data-ttu-id="4a9ec-253">리소스 사용량을 제한할 그러나 가능한 경우 디스크에 스풀링 메시 하 여 공간 표면 사라집니다으로 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-253">It will still need to limit resource usage though, possibly by spooling meshes to disk as spatial surfaces disappear.</span></span>
   * <span data-ttu-id="4a9ec-254">공간 표면 생성 하는 동안 일부 비교적 드문 이벤트와 유사한 위치에 있지만 서로 다른 Id를 사용 하 여 새로운 공간 화면 교체 공간 화면을 일으킬 수 있는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-254">Note that some relatively rare events during spatial surface generation can cause spatial surfaces to be replaced by new spatial surfaces in a similar location but with different IDs.</span></span> <span data-ttu-id="4a9ec-255">따라서 제거 화면을 삭제 하지 않도록 선택 하는 응용 프로그램 주의 해야 최종 필요가 여러 항상 overlapped 공간 표면 메시 다루는 동일한 위치를 사용 하 여 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-255">Consequently, applications that choose not to discard a removed surface should take care not to end up with multiple highly-overlapped spatial surface meshes covering the same location.</span></span>
* <span data-ttu-id="4a9ec-256">다른 공간 표면에 대 한 메시를 삭제 해야?</span><span class="sxs-lookup"><span data-stu-id="4a9ec-256">Should mesh be discarded for any other spatial surfaces?</span></span>
   * <span data-ttu-id="4a9ec-257">공간을 노출 하는 동안에 있는 경우 더 이상 사용자의 환경에 유용한 다음 삭제 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-257">Even while a spatial surface exists, if it is no longer useful to the user's experience then it should be discarded.</span></span> <span data-ttu-id="4a9ec-258">예를 들어 대체 하면이 응용 프로그램 '' 출입구가의 다른 쪽에 공간을 대체 하는 가상 공간을 사용 하 여 다음 공간 화면 해당 공간에 더 이상 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-258">For example, if the application 'replaces' the room on the other side of a doorway with an alternate virtual space then the spatial surfaces in that room no longer matter.</span></span>

<span data-ttu-id="4a9ec-259">예제에서는 메시 캐싱 전략을, 공간 및 임시 이력이 사용 하는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-259">Here is an example mesh caching strategy, using spatial and temporal hysteresis:</span></span>
* <span data-ttu-id="4a9ec-260">응용 프로그램을 사용자의 게이즈 살펴보겠습니다 고 경비원 뒤에 오는 관심 꼭지점이 절 두 체 모양의 공간 볼륨을 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-260">Consider an application that wishes to use a frustum-shaped spatial volume of interest that follows the user's gaze as they look around and walk around.</span></span>
* <span data-ttu-id="4a9ec-261">공간 화면 사라질 수 있습니다 일시적으로이 볼륨에서 단순히 화면에서 사용자가 또는 벗어나면 단계 추가... 다시 확인에 또는 다시 잠시 나중에 더 가깝게 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-261">A spatial surface may disappear temporarily from this volume simply because the user looks away from the surface or steps further away from it... only to look back or moves closer again a moment later.</span></span> <span data-ttu-id="4a9ec-262">이 경우 삭제 하 고 다시이 화면에 대 한 메시를 만드는 많은 중복 처리를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-262">In this case, discarding and re-creating the mesh for this surface represents a lot of redundant processing.</span></span>
* <span data-ttu-id="4a9ec-263">응용 프로그램은 변경 내용이 처리의 수를 줄이려면 두 공간 표면 관찰자를 다른 내에 포함 된 하나를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-263">To reduce the number of changes processed, the application uses two spatial surface observers, one contained within the other.</span></span> <span data-ttu-id="4a9ec-264">첫 번째 볼륨 구형 이며 '지연;' 사용자를 따릅니다. 해당 centre 사용자의 2.0 metres 이내 인지 확인 하는 데 필요한 경우에 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-264">The larger volume is spherical and follows the user 'lazily'; it only moves when necessary to ensure that its centre is within 2.0 metres of the user.</span></span>
* <span data-ttu-id="4a9ec-265">신규 및 업데이트 된 공간 표면 메시에서 더 작은 내부 노출 관찰자를 항상 처리 하지만 메시 큰 외부 노출 observer에서 사라지는 때까지 캐시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-265">New and updated spatial surface meshes are always processed from the smaller inner surface observer, but meshes are cached until they disappear from the larger outer surface observer.</span></span> <span data-ttu-id="4a9ec-266">이 응용 프로그램을을 로컬 사용자 이동으로 인해 많은 중복 변경이 처리 되지 않도록 방지할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-266">This allows the application to avoid processing many redundant changes due to local user movement.</span></span>
* <span data-ttu-id="4a9ec-267">공간 화면도 손실 추적으로 인해 일시적으로 사라질 수 있습니다, 되므로 응용 프로그램 손실 추적 하는 동안 삭제 제거 공간 표면도 지연 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-267">Since a spatial surface may also disappear temporarily due to tracking loss, the application also defers discarding removed spatial surfaces during tracking loss.</span></span>
* <span data-ttu-id="4a9ec-268">일반적으로 응용 프로그램 감소 업데이트 처리 및 메모리 사용 증가 이상적인 캐싱 전략을 결정할 간의 균형을 평가 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-268">In general, an application should evaluate the tradeoff between reduced update processing and increased memory usage to determine its ideal caching strategy.</span></span>

## <a name="rendering"></a><span data-ttu-id="4a9ec-269">렌더링</span><span class="sxs-lookup"><span data-stu-id="4a9ec-269">Rendering</span></span>

<span data-ttu-id="4a9ec-270">세 가지 기본 공간 매핑 메시 렌더링에 사용 되는 경향이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-270">There are three primary ways in which spatial mapping meshes tend to be used for rendering:</span></span>
* <span data-ttu-id="4a9ec-271">Surface 시각화에 대 한</span><span class="sxs-lookup"><span data-stu-id="4a9ec-271">For surface visualization</span></span>
   * <span data-ttu-id="4a9ec-272">화면 공간을 직접 시각화 하는 것이 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-272">It is often useful to visualize spatial surfaces directly.</span></span> <span data-ttu-id="4a9ec-273">예를 들어 공간 표면에 개체를 캐스팅 'shadows' 화면에서 홀로그램 배치 되는 동안 사용자에 게 유용한 시각적 피드백을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-273">For example, casting 'shadows' from objects onto spatial surfaces can provide helpful visual feedback to the user while they are placing holograms on surfaces.</span></span>
   * <span data-ttu-id="4a9ec-274">기억해 야 할 한 가지는 공간 메시 3D artist를 만들 수는 메시의 종류와 다릅니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-274">One thing to bear in mind is that spatial meshes are different to the kind of meshes that a 3D artist might create.</span></span> <span data-ttu-id="4a9ec-275">삼각형 토폴로지 사람이 만든 토폴로지도으로 '정리' 되지 않으며 메시에서 저하 됩니다 [다양 한 오류](spatial-mapping-design.md#what-influences-spatial-mapping-quality)합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-275">The triangle topology will not be as 'clean' as human-created topology, and the mesh will suffer from [various errors](spatial-mapping-design.md#what-influences-spatial-mapping-quality).</span></span>
   * <span data-ttu-id="4a9ec-276">보기 좋게 visual 미학을 만들기 위해 수 있으므로 수행 하려는 일부 [처리 메시](spatial-mapping.md#mesh-processing)채우기 구멍 또는 부드러운 표면 법선을 예를 들어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-276">In order to create a pleasing visual aesthetic, you may thus want to perform some [mesh processing](spatial-mapping.md#mesh-processing), for example to fill holes or smooth surface normals.</span></span> <span data-ttu-id="4a9ec-277">프로젝트 artist 용으로 설계 된 질감을 셰이더를 직접 메시 토폴로지 및 normals를 시각화 하는 대신에 메시를 사용 하도 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-277">You may also wish to use a shader to project artist-designed textures onto your mesh instead of directly visualizing mesh topology and normals.</span></span>
* <span data-ttu-id="4a9ec-278">실제 화면 뒤 홀로그램 occluding에 대 한</span><span class="sxs-lookup"><span data-stu-id="4a9ec-278">For occluding holograms behind real-world surfaces</span></span>
   * <span data-ttu-id="4a9ec-279">공간 화면 깊이 전용 패스에서 어떤만 영향을 렌더링할 수 있습니다 합니다 [깊이 버퍼](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) 색 렌더링 대상에는 영향을 주지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-279">Spatial surfaces can be rendered in a depth-only pass which only affects the [depth buffer](https://msdn.microsoft.com/library/windows/desktop/bb219616(v=vs.85).aspx) and does not affect color render targets.</span></span>
   * <span data-ttu-id="4a9ec-280">이 primes 깊이 버퍼 공간 화면 뒤 이후에 렌더링 홀로그램 채워집니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-280">This primes the depth buffer to occlude subsequently-rendered holograms behind spatial surfaces.</span></span> <span data-ttu-id="4a9ec-281">홀로그램의 정확한 폐색 홀로그램 사용자의 물리적 공간에 실제로 존재 하는지와 같은 의미를 향상 시킵니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-281">Accurate occlusion of holograms enhances the sense that holograms really exist within the user's physical space.</span></span>
   * <span data-ttu-id="4a9ec-282">깊이 전용 렌더링을 사용 하도록 설정 하려면 설정 하려면 혼합 상태를 업데이트 합니다 [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) 를 0으로 모든 색에 대 한 렌더링 대상입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-282">To enable depth-only rendering, update your blend state to set the [RenderTargetWriteMask](https://msdn.microsoft.com/library/windows/desktop/hh404492(v=vs.85).aspx) to zero for all color render targets.</span></span>
* <span data-ttu-id="4a9ec-283">실제 화면에서 폐색 홀로그램의 모양 수정에 대 한</span><span class="sxs-lookup"><span data-stu-id="4a9ec-283">For modifying the appearance of holograms occluded by real-world surfaces</span></span>
   * <span data-ttu-id="4a9ec-284">일반적으로 렌더링 된 기 하 도형 폐색가 하는 경우 숨겨집니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-284">Normally rendered geometry is hidden when it is occluded.</span></span> <span data-ttu-id="4a9ec-285">깊이 함수를 설정 하 여 이렇게 하 [깊이 스텐실 상태](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) 를 "less than 또는 equal", 표시 되도록만 경우 기 하 도형에 이르게 **좀 더 자세히** 보다 이전에 렌더링 모든 카메라 기 하 도형입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-285">This is achieved by setting the depth function in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx) to "less than or equal", which causes geometry to be visible only where it is **closer** to the camera than all previously rendered geometry.</span></span>
   * <span data-ttu-id="4a9ec-286">그러나가 내포 되었는지 하는 경우에 특정 기 하 도형이 보이도록 유지 하 고 사용자에 게 시각적 피드백을 제공 하는 방법으로 폐색 때 모양을 수정할 수 것이 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-286">However, it may be useful to keep certain geometry visible even when it is occluded, and to modify its appearance when occluded as a way of providing visual feedback to the user.</span></span> <span data-ttu-id="4a9ec-287">예를 들어, 응용 프로그램을 사용자는 명확 하 게 시 개체의 위치는 실제 화면 뒤에 표시할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-287">For example, this allows the application to show the user the location of an object whilst making it clear that is behind a real-world surface.</span></span>
   * <span data-ttu-id="4a9ec-288">이 위해 기 하 도형을 만드는 원하는 'occluded' 모양을 다른 셰이더와 함께 두 번째로 렌더링 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-288">To achieve this, render the geometry a second time with a different shader that creates the desired 'occluded' appearance.</span></span> <span data-ttu-id="4a9ec-289">두 번째 시간에 대 한 기 하 도형을 렌더링 하기 전에 두 가지 사항을 변경 하 여 [깊이 스텐실 상태](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-289">Before rendering the geometry for the second time, make two changes to your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="4a9ec-290">먼저, "크거나 같음" 깊이 함수 설정 되도록 기 하 도형을 표시만 것 **추가로** 모든 이전에 렌더링 된 기 하 도형 보다 카메라에서.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-290">First, set the depth function to "greater than or equal" so that the geometry will be visible only where it is **further** from the camera than all previously rendered geometry.</span></span> <span data-ttu-id="4a9ec-291">두 번째로, 깊이 버퍼를 수정할 수는 없도록는 DepthWriteMask를 0으로 설정 (깊이 버퍼를 나타내는 기 하 도형의 깊이 계속할지 **가장 가까운** 카메라).</span><span class="sxs-lookup"><span data-stu-id="4a9ec-291">Second, set the DepthWriteMask to zero, so that the depth buffer will not be modified (the depth buffer should continue to represent the depth of the geometry **closest** to the camera).</span></span>

<span data-ttu-id="4a9ec-292">[성능](understanding-performance-for-mixed-reality.md) 공간 매핑 메시를 렌더링할 때 중요 한 문제는 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-292">[Performance](understanding-performance-for-mixed-reality.md) is an important concern when rendering spatial mapping meshes.</span></span> <span data-ttu-id="4a9ec-293">여기 일부의 렌더링 성능 기술을 공간 매핑 메시 렌더링 관련:</span><span class="sxs-lookup"><span data-stu-id="4a9ec-293">Here are some rendering performance techniques specific to rendering spatial mapping meshes:</span></span>
* <span data-ttu-id="4a9ec-294">삼각형 밀도 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-294">Adjust triangle density</span></span>
   * <span data-ttu-id="4a9ec-295">요청 공간 화면에 노출 observer에서 메시를 경우 가장 낮은 밀도 맞게를 삼각형 메시를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-295">When requesting spatial surface meshes from your surface observer, request the lowest density of triangle meshes that will suffice for your needs.</span></span>
   * <span data-ttu-id="4a9ec-296">사용자의 화면을 거리에 따라 화면에서 화면으로 삼각형 밀도 변경 하려면 적합할 수 있습니다 및 사용자 환경에 해당 관련성입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-296">It may make sense to vary triangle density on a surface by surface basis, depending on the surface's distance from the user, and its relevance to the user experience.</span></span>
   * <span data-ttu-id="4a9ec-297">감소 삼각형 수 픽셀 처리 비용 영향을 주지 것입니다 하지만 메모리 사용량 및 GPU에서 꼭 짓 점 처리 비용이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-297">Reducing triangle counts will reduce memory usage and vertex processing costs on the GPU, though it will not affect pixel processing costs.</span></span>
* <span data-ttu-id="4a9ec-298">수행할 꼭지점이 절 두 체 고르기</span><span class="sxs-lookup"><span data-stu-id="4a9ec-298">Perform frustum culling</span></span>
   * <span data-ttu-id="4a9ec-299">꼭지점이 절 두 체 고르기 하면 현재 표시 프러스텀 외부 이기 때문에 나타나지 않는 그리기 개체를 건너뜁니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-299">Frustum culling skips drawing objects that cannot be seen because they are outside the current display frustum.</span></span> <span data-ttu-id="4a9ec-300">따라서 CPU와 GPU 처리 비용이 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-300">This reduces both CPU and GPU processing costs.</span></span>
   * <span data-ttu-id="4a9ec-301">메시 당 단위로 수행 됩니다 고르기 이므로 공간 표면 클 수 있습니다 더 작은 청크로 각 공간 표면 메시를 중단 될 수 있습니다 효율적 고르기 (에 더 적은 오프 스크린 삼각형 렌더링 됩니다).</span><span class="sxs-lookup"><span data-stu-id="4a9ec-301">Since culling is performed on a per-mesh basis and spatial surfaces can be large, breaking each spatial surface mesh into smaller chunks may result in more efficient culling (in that fewer offscreen triangles are rendered).</span></span> <span data-ttu-id="4a9ec-302">에 장단점이 있습니다를 권장 합니다. 해야 자세한 메시, 자세한 그리기 호출 수행 해야 하는 CPU 비용이 증가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-302">There is a tradeoff, however; the more meshes you have, the more draw calls you must make, which can increase CPU costs.</span></span> <span data-ttu-id="4a9ec-303">극단적인 경우 자체 계산을 고르기 하면 프러스텀 비용 측정 가능한 CPU를도 있을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-303">In an extreme case, the frustum culling calculations themselves could even have a measurable CPU cost.</span></span>
* <span data-ttu-id="4a9ec-304">렌더링 순서를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-304">Adjust rendering order</span></span>
   * <span data-ttu-id="4a9ec-305">공간 표면 둘러싸인 사용자의 전체 환경 멀 기 때문에 큰 경우가 많습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-305">Spatial surfaces tend to be large, because they represent the user's entire environment surrounding them.</span></span> <span data-ttu-id="4a9ec-306">GPU에서 비용을 처리 하는 픽셀의 경우에 특히 높은 수 있으므로 둘 이상의 계층이 표시 되는 기 (공간 표면 및 다른 홀로그램 모두 포함)의 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-306">Pixel processing costs on the GPU can thus be high, especially in cases where there is more than one layer of visible geometry (including both spatial surfaces and other holograms).</span></span> <span data-ttu-id="4a9ec-307">이 경우 사용자와 가장 가까운 계층은 수 occluding 모든 계층을 추가 제거 더 멀리 떨어져 있는 계층을 렌더링 하는 데 걸린 하 모든 GPU 시간을 소비 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-307">In this case, the layer nearest to the user will be occluding any layers further away, so any GPU time spent rendering those more distant layers is wasted.</span></span>
   * <span data-ttu-id="4a9ec-308">GPU에서 중복이 작업을 줄이기 위해 앞에서 뒤로 순서로 불투명 화면을 렌더링 하는 (좀 더 자세히 선언은 첫 번째, 더 멀리 떨어진 것 마지막).</span><span class="sxs-lookup"><span data-stu-id="4a9ec-308">To reduce this redundant work on the GPU, it helps to render opaque surfaces in front-to-back order (closer ones first, more distant ones last).</span></span> <span data-ttu-id="4a9ec-309">'불투명' 의미는 DepthWriteMask에서 설정 된 표면에 [깊이 스텐실 상태](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx)합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-309">By 'opaque' we mean surfaces for which the DepthWriteMask is set to one in your [depth-stencil state](https://msdn.microsoft.com/library/windows/desktop/ff476110(v=vs.85).aspx).</span></span> <span data-ttu-id="4a9ec-310">가장 가까운 화면 렌더링 되 면 GPU에서 픽셀 프로세서 더 먼 서피스를 효율적으로 건너뛰도록 깊이 버퍼를 소수는 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-310">When the nearest surfaces are rendered, they will prime the depth buffer so that more distant surfaces are efficiently skipped by the pixel processor on the GPU.</span></span>

## <a name="mesh-processing"></a><span data-ttu-id="4a9ec-311">메시 처리</span><span class="sxs-lookup"><span data-stu-id="4a9ec-311">Mesh Processing</span></span>

<span data-ttu-id="4a9ec-312">응용 프로그램을 수행 하려는 [다양 한 작업](spatial-mapping.md#mesh-processing) 요구 사항에 맞게 공간 표면 메시의 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-312">An application may want to perform [various operations](spatial-mapping.md#mesh-processing) on spatial surface meshes to suit its needs.</span></span> <span data-ttu-id="4a9ec-313">각 공간 표면 메시를 사용 하 여 제공 되는 인덱스 및 꼭 짓 점 데이터와 같은 친숙 한 레이아웃이 사용 합니다 [꼭 짓 점 및 인덱스 버퍼](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) 모든 최신 렌더링 Api에에서는 삼각형 메시를 렌더링 하는 데 사용 되는 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-313">The index and vertex data provided with each spatial surface mesh uses the same familiar layout as the [vertex and index buffers](https://msdn.microsoft.com/library/windows/desktop/bb147325%28v=vs.85%29.aspx) that are used for rendering triangle meshes in all modern rendering APIs.</span></span> <span data-ttu-id="4a9ec-314">그러나 하나의 키 알아야 할 사실 공간 매핑 삼각형에는 **프런트 시계 감기 순서**합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-314">However, one key fact to be aware of is that spatial mapping triangles have a **front-clockwise winding order**.</span></span> <span data-ttu-id="4a9ec-315">각 삼각형 메시의 인덱스 버퍼에 3 개의 꼭 짓 점 인덱스에서 표현 되 고 이러한 인덱스의 삼각형의 꼭 짓 점 식별 하는 **시계** 순서에서 삼각형을 볼 때 합니다 **프런트** 쪽 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-315">Each triangle is represented by three vertex indices in the mesh's index buffer and these indices will identify the triangle's vertices in a **clockwise** order, when the triangle is viewed from the **front** side.</span></span> <span data-ttu-id="4a9ec-316">앞 쪽 (또는 외부) 공간 표면 메시의 실제 화면의 프런트 (표시) 옆에 예상한 대로 해당 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-316">The front side (or outside) of spatial surface meshes corresponds as you would expect to the front (visible) side of real world surfaces.</span></span>

<span data-ttu-id="4a9ec-317">응용 프로그램 노출 관찰자를 제공한 통해 삼각형 밀도 여전히 분산이 정교 하지 않은 경우이 작업은 계산을 많이 메시 단순화 하 고 다양 한를 생성 하기 위해 런타임에서 이미 수행만 수행 해야 수준의 세부 정보를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-317">Applications should only perform mesh simplification if the coarsest triangle density provided by the surface observer is still insufficiently coarse - this work is computationally expensive and already being performed by the runtime to generate the various provided levels of detail.</span></span>

<span data-ttu-id="4a9ec-318">이러한 공간 클립 할 일부 응용 프로그램 노출 된 각 관찰자가 여러 연결 되지 않은 공간 표면에 제공할 수 있으므로 화면 메시 다른 각 다음 지퍼가 대해 해당 함께 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-318">Because each surface observer can provide multiple unconnected spatial surfaces, some applications may wish to clip these spatial surface meshes against each other, then zipper them together.</span></span> <span data-ttu-id="4a9ec-319">일반적으로 클리핑 단계 공간 표면 메시 주변 종종 서로 조금씩 중첩으로 필수입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-319">In general, the clipping step is required, as nearby spatial surface meshes often overlap slightly.</span></span>

## <a name="raycasting-and-collision"></a><span data-ttu-id="4a9ec-320">플레이어가 및 충돌</span><span class="sxs-lookup"><span data-stu-id="4a9ec-320">Raycasting and Collision</span></span>

<span data-ttu-id="4a9ec-321">물리 API에 대 한 순서 대로 (같은 [Havok](http://www.havok.com/)) 공간 표면에 플레이어가 및 충돌 하는 기능을 사용 하 여 응용 프로그램을 제공, 응용 프로그램 공간 표면 메시 물리학 API 제공 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-321">In order for a physics API (such as [Havok](http://www.havok.com/)) to provide an application with raycasting and collision functionality for spatial surfaces, the application must provide spatial surface meshes to the physics API.</span></span> <span data-ttu-id="4a9ec-322">물리학에 대 한 자주 사용 하는 메시에 다음 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-322">Meshes used for physics often have the following properties:</span></span>
* <span data-ttu-id="4a9ec-323">삼각형의 작은 숫자만 포함 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-323">They contain only small numbers of triangles.</span></span> <span data-ttu-id="4a9ec-324">물리학 연산은 자세한 렌더링 작업 보다 계산 집약적.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-324">Physics operations are more computationally intensive than rendering operations.</span></span>
* <span data-ttu-id="4a9ec-325">' 최고 수 위 타이트 ' 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-325">They are 'water-tight'.</span></span> <span data-ttu-id="4a9ec-326">화면 확고 하는 데에 작은 구멍에;를 사용 해야 합니다. 도 구멍 너무 작아서 표시할 수 없는 문제가 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-326">Surfaces intended to be solid should not have small holes in them; even holes too small to be visible can cause problems.</span></span>
* <span data-ttu-id="4a9ec-327">볼록 스로 변환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-327">They are converted into convex hulls.</span></span> <span data-ttu-id="4a9ec-328">볼록 스 몇 다각형 구멍의 무료 및 원시 삼각형 메시 보다 처리 하는 데 훨씬 더 계산 효율적입니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-328">Convex hulls have few polygons and are free of holes, and they are much more computationally efficient to process than raw triangle meshes.</span></span>

<span data-ttu-id="4a9ec-329">혼잡된 셰이프만 복잡 거의 정보-의 전체 등의 공간 표면에 대해 수행 하 고 raycasts 염두에 이러한 화면 복잡 한 경우가 때 책상!</span><span class="sxs-lookup"><span data-stu-id="4a9ec-329">When performing raycasts against spatial surfaces, bear in mind that these surfaces are often complex, cluttered shapes full of messy little details - just like your desk!</span></span> <span data-ttu-id="4a9ec-330">이 단일 raycast 하지 않음을 종종 화면 및 빈 공간 가까운 곳의 모양을 셰이프에 대 한 충분 한 정보를 제공 하는 데 충분 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-330">This means that a single raycast is often insufficient to give you enough information about the shape of the surface and the shape of the empty space near it.</span></span> <span data-ttu-id="4a9ec-331">것이 있으므로 일반적으로 많은 raycasts 작은 영역 내에서 수행 하 고 화면에 대 한 더 신뢰할 수 있는 이해를 파생 시키는 집계 결과 사용 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-331">It is thus usually a good idea to perform many raycasts within a small area and to use the aggregate results to derive a more reliable understanding of the surface.</span></span> <span data-ttu-id="4a9ec-332">예를 들어, 10 raycasts의 평균 화면에서 가이드 홀로그램 배치를 사용 하 여 결과가 나옵니다을 훨씬 원활 하 고 작은 '흔들림'는 단일 raycast만 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-332">For example, using the average of 10 raycasts to guide hologram placement on a surface will yield a far smoother and less 'jittery' result that using just a single raycast.</span></span>

<span data-ttu-id="4a9ec-333">그러나 각 raycast 계산 비용을 높이 수에 주의 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-333">However, bear in mind that each raycast can have a high computational cost.</span></span> <span data-ttu-id="4a9ec-334">따라서 사용 시나리오에 따라 해야 희생 할 추가 raycasts의 계산 비용 (프레임 마다 수행 됨)의 계산 비용 대비 [처리 메시](spatial-mapping.md#mesh-processing) 부드러운 공간 표면 (에서 구멍을 제거 하 공간 메시를 업데이트할 때 수행).</span><span class="sxs-lookup"><span data-stu-id="4a9ec-334">Thus depending on your usage scenario you should trade off the computational cost of additional raycasts (performed every frame) against the computational cost of [mesh processing](spatial-mapping.md#mesh-processing) to smooth and remove holes in spatial surfaces (performed when spatial meshes are updated).</span></span>

## <a name="troubleshooting"></a><span data-ttu-id="4a9ec-335">문제 해결</span><span class="sxs-lookup"><span data-stu-id="4a9ec-335">Troubleshooting</span></span>
* <span data-ttu-id="4a9ec-336">올바르게 orientated 되도록 표면 메시에 대 한 순서 대로 각 GameObject 생성 해당 메시 할는 SurfaceObeserver에 전송 되기 전에 활성화 되도록 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-336">In order for the surface meshes to be orientated correctly, each GameObject needs to be active before it is sent to the SurfaceObeserver to have its mesh constructed.</span></span> <span data-ttu-id="4a9ec-337">이 고, 그렇지는 메시 이상한 각도로 회전 되지만 공간에 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-337">Otherwise, the meshes will show up in your space but rotated at weird angles.</span></span>
* <span data-ttu-id="4a9ec-338">GameObject를 SurfaceObserver를 사용 하 여 통신 하는 스크립트를 실행 하는 원본으로 설정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-338">The GameObject that runs the script that communicates with the SurfaceObserver needs to be set to the origin.</span></span> <span data-ttu-id="4a9ec-339">그렇지 않으면 모든 Gameobject 만들고 생성 된 해당 메시 할는 SurfaceObserver 보내기는 부모 게임 개체의 오프셋으로 오프셋을 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-339">Otherwise, all of GameObjects that you create and send to the SurfaceObserver to have their meshes constructed will have an offset equal to the offset of the Parent Game Object.</span></span> <span data-ttu-id="4a9ec-340">이 여러 미터 떨어진 것 디버그 하기가 매우 어렵습니다 그러면 표시 하 여 메시를 만들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="4a9ec-340">This can make your meshes show up several meters away which makes it very hard to debug what is going on.</span></span>

## <a name="see-also"></a><span data-ttu-id="4a9ec-341">참조</span><span class="sxs-lookup"><span data-stu-id="4a9ec-341">See also</span></span>
* [<span data-ttu-id="4a9ec-342">좌표계</span><span class="sxs-lookup"><span data-stu-id="4a9ec-342">Coordinate systems</span></span>](coordinate-systems.md)
* [<span data-ttu-id="4a9ec-343">DirectX의 공간 매핑</span><span class="sxs-lookup"><span data-stu-id="4a9ec-343">Spatial mapping in DirectX</span></span>](spatial-mapping-in-directx.md)
* [<span data-ttu-id="4a9ec-344">Unity에서 공간 매핑</span><span class="sxs-lookup"><span data-stu-id="4a9ec-344">Spatial mapping in Unity</span></span>](spatial-mapping-in-unity.md)
* [<span data-ttu-id="4a9ec-345">공간 매핑 디자인</span><span class="sxs-lookup"><span data-stu-id="4a9ec-345">Spatial mapping design</span></span>](spatial-mapping-design.md)
* [<span data-ttu-id="4a9ec-346">사례 연구-구멍에 실제로 탐색</span><span class="sxs-lookup"><span data-stu-id="4a9ec-346">Case study - Looking through holes in your reality</span></span>](case-study-looking-through-holes-in-your-reality.md)
