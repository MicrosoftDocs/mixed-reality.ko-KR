---
title: HoloLens 2를 위한 앱 준비
description: HoloLens(1세대) 및/또는 이전 MRTK에 기존 앱이 있으며 MRTK 버전 2 및 HoloLens 2로 이식하려는 개발자를 대상으로 합니다.
author: grbury
ms.author: grbury
ms.date: 04/12/19
ms.topic: article
ms.localizationpriority: high
keywords: Windows Mixed Reality, test, MRTK, MRTK version 2, HoloLens 2
ms.openlocfilehash: 02dabd21b7a6add2ce53fe291a447e49057184d0
ms.sourcegitcommit: f20beea6a539d04e1d1fc98116f7601137eebebe
ms.translationtype: HT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/05/2019
ms.locfileid: "66270390"
---
# <a name="getting-your-existing-app-ready-for-hololens-2"></a><span data-ttu-id="af03a-104">HoloLens 2를 위한 기존 앱 준비</span><span class="sxs-lookup"><span data-stu-id="af03a-104">Getting your existing app ready for HoloLens 2</span></span>

<span data-ttu-id="af03a-105">이 가이드는 HoloLens(1세대)용 기존 Unity 앱이 있는 개발자가 새 HoloLens 2 디바이스용 애플리케이션을 이식하는 것을 지원하기 위해 특수하게 고안되었습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-105">This guide is specifically tailored to help developers who have an existing Unity app for HoloLens (1st gen) to port their application for the new HoloLens 2 device.</span></span> <span data-ttu-id="af03a-106">HoloLens(1세대) Unity 앱을 HoloLens 2로 이식하기 위한 핵심 단계에는 4가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-106">There are four key steps to porting a HoloLens (1st gen) Unity app to HoloLens 2.</span></span> <span data-ttu-id="af03a-107">아래 섹션에서는 각 단계에 대한 정보를 자세히 설명합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-107">The sections below will detail information for each stage.</span></span> 

| <span data-ttu-id="af03a-108">1단계</span><span class="sxs-lookup"><span data-stu-id="af03a-108">Step 1</span></span> | <span data-ttu-id="af03a-109">2단계</span><span class="sxs-lookup"><span data-stu-id="af03a-109">Step 2</span></span> | <span data-ttu-id="af03a-110">3단계</span><span class="sxs-lookup"><span data-stu-id="af03a-110">Step 3</span></span> | <span data-ttu-id="af03a-111">4단계</span><span class="sxs-lookup"><span data-stu-id="af03a-111">Step 4</span></span> |
|----------|-------------------|-------------------|-------------------|
| ![Visual Studio 로고](images/visualstudio_logo.png) | ![Unity 로고](images/unity_logo.png)| ![Unity 아이콘](images/hololens2_icon.jpg) | ![MRTK 로고](images/MRTKIcon.jpg) |
| <span data-ttu-id="af03a-116">최신 도구 다운로드</span><span class="sxs-lookup"><span data-stu-id="af03a-116">Download latest tools</span></span> | <span data-ttu-id="af03a-117">Unity 프로젝트 업데이트</span><span class="sxs-lookup"><span data-stu-id="af03a-117">Update Unity Project</span></span> | <span data-ttu-id="af03a-118">ARM용 컴파일</span><span class="sxs-lookup"><span data-stu-id="af03a-118">Compile for ARM</span></span> | <span data-ttu-id="af03a-119">MRTK v2로 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="af03a-119">Migrate to MRTK v2</span></span>

<span data-ttu-id="af03a-120">개발자는 이식 프로세스를 시작하기 전에 소스 제어를 활용하여 앱의 원래 상태 스냅샷을 저장하는 것이 **좋습니다**.</span><span class="sxs-lookup"><span data-stu-id="af03a-120">It is **highly recommended** that, before beginning the porting process, developers utilize source control to save a snapshot of the original state of their app.</span></span> <span data-ttu-id="af03a-121">또한 이 프로세스의 다양한 시점에서 검사점 상태를 *저장*하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-121">Additionally, it is recommended to *save* checkpoint states at various points during the process.</span></span> <span data-ttu-id="af03a-122">또한 이식 프로세스 동안 나란히 비교할 수 있도록 원래 앱의 다른 Unity 인스턴스를 유지하는 것이 매우 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-122">It can also be very helpful to have another Unity instance of the original app to allow for side-by-side comparison during the port process.</span></span> 

> [!NOTE]
> <span data-ttu-id="af03a-123">이식하기 전에 Windows Mixed Reality 개발을 위한 최신 도구를 설치했는지 확인합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-123">Before porting, ensure you have the latest tools installed for Windows Mixed Reality development.</span></span> <span data-ttu-id="af03a-124">대부분의 기존 HoloLens 개발자의 경우 이 작업을 위해 최신 Visual Studio 2017로 업데이트하고 적절한 Windows SDK를 설치하게 됩니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-124">For most existing HoloLens developers, this will primarily involve updating to the latest Visual Studio 2017 and installing the appropriate Windows SDK.</span></span> <span data-ttu-id="af03a-125">아래의 내용은 여러 다른 Unity 버전과 Mixed Reality Toolkit 버전 2를 좀 더 자세히 알아봅니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-125">The content below will dive further into different Unity versions and the Mixed Reality Toolkit version 2.</span></span>
>
> <span data-ttu-id="af03a-126">자세한 내용은 [도구 설치](install-the-tools.md)를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="af03a-126">For more information, please see [Install the tools](install-the-tools.md).</span></span>

## <a name="migrate-project-to-latest-version-of-unity"></a><span data-ttu-id="af03a-127">최신 버전의 Unity로 프로젝트 마이그레이션</span><span class="sxs-lookup"><span data-stu-id="af03a-127">Migrate project to latest version of Unity</span></span>

<span data-ttu-id="af03a-128">MRTK v2를 사용하는 경우 Unity 2018 LTS는 Unity 또는 MRTK가 획기적으로 변경되지 않는 가장 적합한 장기적인 지원 경로가 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-128">If using the MRTK v2, then Unity 2018 LTS will be the best long-term support path with no breaking changes in Unity or in MRTK.</span></span>  <span data-ttu-id="af03a-129">위의 "도구 설치"에 따르면 권장되는 Unity 빌드는 Unity 2018.3으로, Unity 2018용 LTS 릴리스가 될 것입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-129">The recommended Unity build, per the above "install the tools" is Unity 2018.3, which will become the LTS release for Unity 2018.</span></span>  <span data-ttu-id="af03a-130">그뿐 아니라 MRTK v2는 항상 Unity 2018 LTS를 지원할 예정이지만 모든 Unity 2019.x를 반드시 지원할 것으로 보장할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-130">Further, the MRTK v2 will always guarantee support for Unity 2018 LTS but not necessarily guarantee support for every iteration of Unity 2019.x.</span></span> 

<span data-ttu-id="af03a-131">Unity 2018.3.x 또는 Unity 2019.1.x 간의 추가적인 차이점을 명확히 나타내기 위해 아래에서는 이러한 두 버전 간의 장단점을 대략적으로 설명합니다. 두 버전의 중대한 주요 차이점은 Unity 2019에서는 ARM64용 컴파일을 수행할 수 있도록 지원된다는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-131">To help clarify additional differences between Unity 2018.3.x or Unity 2019.1.x, below outlines the trade-offs between these two versions, with the primary difference of significance being the ability to compile for ARM64 in Unity 2019.</span></span> 

<span data-ttu-id="af03a-132">개발자는 현재 해당 프로젝트에 존재하는[플러그 인 종속성](https://docs.unity3d.com/Manual/Plugins.html)과 이러한 DLL을 ARM64용으로 빌드할 수 있는지 여부를 평가해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-132">Developers should assess any [plugin dependencies](https://docs.unity3d.com/Manual/Plugins.html) that currently exist in their project and whether or not these DLLs can be built for ARM64.</span></span> <span data-ttu-id="af03a-133">ARM64용으로 강한 종속성 플러그 인을 빌드할 수 없는 경우 Unity 2018 LTS를 활용해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-133">If a hard dependency plugin cannot be built for ARM64, then one will have to utilize Unity 2018 LTS.</span></span>


| <span data-ttu-id="af03a-134">Unity 2018.3.x</span><span class="sxs-lookup"><span data-stu-id="af03a-134">Unity 2018.3.x</span></span> | <span data-ttu-id="af03a-135">Unity 2019.1+</span><span class="sxs-lookup"><span data-stu-id="af03a-135">Unity 2019.1+</span></span> |
|----------|-------------------|
| <span data-ttu-id="af03a-136">ARM32 빌드 지원</span><span class="sxs-lookup"><span data-stu-id="af03a-136">ARM32 build support</span></span> | <span data-ttu-id="af03a-137">ARM64 및 ARM32 빌드 지원</span><span class="sxs-lookup"><span data-stu-id="af03a-137">ARM32 and ARM64 build support</span></span> |
| <span data-ttu-id="af03a-138">안정적인 LTS 릴리스 빌드</span><span class="sxs-lookup"><span data-stu-id="af03a-138">Stable LTS build release</span></span> | <span data-ttu-id="af03a-139">베타 안정성</span><span class="sxs-lookup"><span data-stu-id="af03a-139">Beta stability</span></span> |
| <span data-ttu-id="af03a-140">[.NET 스크립팅 백 엔드](https://docs.unity3d.com/Manual/windowsstore-dotnet.html) *사용되지 않음*</span><span class="sxs-lookup"><span data-stu-id="af03a-140">[.NET Scripting back-end](https://docs.unity3d.com/Manual/windowsstore-dotnet.html) *deprecated*</span></span> | <span data-ttu-id="af03a-141">[.NET 스크립팅 백 엔드](https://docs.unity3d.com/Manual/windowsstore-dotnet.html) *제거됨*</span><span class="sxs-lookup"><span data-stu-id="af03a-141">[.NET Scripting back-end](https://docs.unity3d.com/Manual/windowsstore-dotnet.html) *removed*</span></span> |
| <span data-ttu-id="af03a-142">UNET 네트워킹 *사용되지 않음*</span><span class="sxs-lookup"><span data-stu-id="af03a-142">UNET Networking *deprecated*</span></span> | <span data-ttu-id="af03a-143">UNET 네트워킹 *제거됨*</span><span class="sxs-lookup"><span data-stu-id="af03a-143">UNET Networking *removed*</span></span> |

## <a name="update-sceneproject-settings-in-unity"></a><span data-ttu-id="af03a-144">Unity에서 장면/프로젝트 설정 업데이트</span><span class="sxs-lookup"><span data-stu-id="af03a-144">Update scene/project settings in Unity</span></span>

<span data-ttu-id="af03a-145">Unity 2018.3.x 또는 Unity 2019+로 업데이트한 후에는 디바이스에서 최적의 결과를 얻기 위해 Unity에서 특정 설정을 업데이트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-145">After updating to Unity 2018.3.x or Unity 2019+, it is recommended to update particular settings in Unity for optimal results on device.</span></span> <span data-ttu-id="af03a-146">이러한 설정은 **[Unity의 권장 설정](Recommended-settings-for-Unity.md)** 아래에서 자세히 설명되어 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-146">These settings are outlined in detail under **[Recommended settings for Unity](Recommended-settings-for-Unity.md)**.</span></span>

<span data-ttu-id="af03a-147">다시 말하지만 [.NET 스크립팅 백 엔드](https://docs.unity3d.com/Manual/windowsstore-dotnet.html)는 Unity 2018에서 더 이상 사용되지 않고 Unity 2019에서 *제거*되었으므로 개발자는 프로젝트를 [IL2CPP](https://docs.unity3d.com/Manual/IL2CPP.html)로 전환할 것을 강력히 고려해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-147">It should be re-iterated that the [.NET Scripting back-end](https://docs.unity3d.com/Manual/windowsstore-dotnet.html) is being deprecated in Unity 2018 and *removed* in Unity 2019 and thus, developers should strongly consider switching their project over to [IL2CPP](https://docs.unity3d.com/Manual/IL2CPP.html).</span></span> 

> [!NOTE]
> <span data-ttu-id="af03a-148">IL2CPP 스크립팅 백 엔드는 Unity에서 Visual Studio로의 빌드 시간이 더 오래 걸리도록 할 수 있으므로 개발자는 [IL2CPP 빌드 시간을 최적화](https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html)하도록 개발자 컴퓨터를 설정해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-148">IL2CPP scripting back-end can cause longer build times from Unity to Visual Studio and thus developers should setup their developer machine for [optimizing IL2CPP build times](https://docs.unity3d.com/Manual/IL2CPP-OptimizingBuildTimes.html).</span></span>
> <span data-ttu-id="af03a-149">또한 대용량 자산(스크립트 파일 제외) 또는 지속적으로 변화하는 장면/자산을 포함하는 Unity 프로젝트에 맞게 [캐시 서버](https://docs.unity3d.com/Manual/CacheServer.html)를 설정하는 것도 유용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-149">Furthermore, it may be beneficial to setup a [Cache Server](https://docs.unity3d.com/Manual/CacheServer.html), especially for Unity projects with a large amount of assets (excluding script files) or constantly changing scenes/assets.</span></span> <span data-ttu-id="af03a-150">프로젝트를 열 때 Unity는 정식 자산을 개발자 컴퓨터에 내부 캐시 형식으로 저장합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-150">When opening a project, Unity stores qualifying assets into an internal cache format on the developer machine.</span></span> <span data-ttu-id="af03a-151">따라서 항목이 수정되면 다시 가져온 후 다시 처리해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-151">Items must be re-imported and thus re-processed when modified.</span></span> <span data-ttu-id="af03a-152">모든 개발자가 새 변경 내용을 로컬로 다시 가져오지 않고, 이 프로세스를 한 번 수행한 후 캐시 서버에 저장하고, 이후에 다른 개발자와 공유할 수 있으므로 시간을 절약할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-152">This process can be done once and saved in a Cache Server and consequently shared with other developers to save time, instead of every developer processing the re-import of new changes locally.</span></span>

<span data-ttu-id="af03a-153">업데이트된 Unity 버전으로 이동한 후에 주요 변경 내용을 처리한 다음, HoloLens(1세대)에서 현재 앱을 빌드하고 테스트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-153">After addressing any breaking changes after moving to the updated Unity version, developers should build and test their current apps on HoloLens (1st gen).</span></span> <span data-ttu-id="af03a-154">또한 이때 소스 제어를 위한 커밋을 만들고 저장하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-154">Further, this is a good point to create and save a commit for source control.</span></span> 

## <a name="compile-dependenciesplugins-for-arm-processor"></a><span data-ttu-id="af03a-155">ARM 프로세서에 대한 종속성/플러그 인 컴파일</span><span class="sxs-lookup"><span data-stu-id="af03a-155">Compile dependencies/plugins for ARM processor</span></span>

<span data-ttu-id="af03a-156">HoloLens(1세대)은 x86 프로세서에서 애플리케이션을 실행했지만, 새 HoloLens 2 디바이스는 ARM 프로세서를 활용합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-156">HoloLens (1st gen) executed applications on an x86 processor while the new HoloLens 2 device utilizes an ARM processor.</span></span> <span data-ttu-id="af03a-157">따라서 기존 애플리케이션을 ARM을 지원하도록 이식해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-157">Thus, existing applications need to be ported over to support ARM.</span></span> <span data-ttu-id="af03a-158">앞에서 설명한 대로 Unity 2018은 ARM32 앱 컴파일을 지원하지만, Unity 2019+는 ARM64 앱 컴파일을 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-158">As noted earlier, Unity 2018 supports compiling for ARM32 apps while Unity 2019+ supports compiling for ARM64 apps.</span></span> <span data-ttu-id="af03a-159">구체적인 성능상 차이는 없으므로 ARM64 애플리케이션 개발이 일반적으로 선호됩니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-159">Developing for ARM64 applications is generally preferred as there is a material difference in performance.</span></span> <span data-ttu-id="af03a-160">그러나 이 경우 ARM64에 대해 모든 [플러그 인 종속성](https://docs.unity3d.com/Manual/Plugins.html)도 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-160">However, this requires all [plugin dependencies](https://docs.unity3d.com/Manual/Plugins.html) to also be built for ARM64.</span></span> 

<span data-ttu-id="af03a-161">현재 애플리케이션에서 모든 DLL 종속성을 검토하세요.</span><span class="sxs-lookup"><span data-stu-id="af03a-161">Review all DLL dependencies in your application currently.</span></span> <span data-ttu-id="af03a-162">종속성이 더 이상 필요하지 않으면 프로젝트에서 제거하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-162">If a dependency is no longer needed, it is advisable to remove it from your project.</span></span> <span data-ttu-id="af03a-163">필요한 나머지 플러그 인의 경우 해당 ARM32 또는 ARM64 이진 파일을 Unity 프로젝트로 수집합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-163">For remaining plugins that are required, ingest the respective ARM32 or ARM64 binaries into your Unity project.</span></span> 

<span data-ttu-id="af03a-164">관련 DLL을 수집한 후에는 Unity에서 Visual Studio 솔루션을 빌드한 후 Visual Studio에서 ARM용 AppX를 컴파일하여 ARM 프로세서용으로 애플리케이션을 빌드할 수 있는지 테스트합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-164">After ingesting the relevant DLLs, build a Visual Studio solution from Unity and then compile an AppX for ARM in Visual Studio to test that your application can be built for ARM processors.</span></span> <span data-ttu-id="af03a-165">이러한 목적으로 소스 제어 솔루션에서 커밋을 저장하는 것도 유용합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-165">This another point where it is advised to save a commit in your source control solution.</span></span> 

## <a name="update-to-mrtk-version-2"></a><span data-ttu-id="af03a-166">MRTK 버전 2로 업데이트</span><span class="sxs-lookup"><span data-stu-id="af03a-166">Update to MRTK version 2</span></span>

<span data-ttu-id="af03a-167">MRTK 버전 2는 두 HoloLens(1세대) 및 HoloLens 2를 둘 다 지원하는 Unity 기반의 새 도구 키트로, 손 조작 및 시선 추적과 같은 새로운 HoloLens 2 기능이 모두 추가되었습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-167">MRTK version 2 is the new toolkit on top of Unity supporting both HoloLens (1st gen) and HoloLens 2, and where all of the new HoloLens 2 capabilities have been added, such as hand interactions and eye tracking.</span></span>

### <a name="prepare-for-the-migration"></a><span data-ttu-id="af03a-168">마이그레이션 준비</span><span class="sxs-lookup"><span data-stu-id="af03a-168">Prepare for the migration</span></span>

<span data-ttu-id="af03a-169">새 [MRTK v2용 \*.unitypackage 파일](https://github.com/Microsoft/MixedRealityToolkit-Unity/releases)을 삽입하기 전에 **1) MRTK v1과 통합되는 사용자 지정 코드** 및 **2) 입력 상호 작용 또는 UX 구성 요소에 대한 사용자 지정 코드** 인벤토리를 만드는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-169">Before ingesting the new [\*.unitypackage files for MRTK v2](https://github.com/Microsoft/MixedRealityToolkit-Unity/releases), it is recommended to take an inventory of **1) any custom-built code that integrates with MRTK v1** and **2) any custom-built code for input interactions or UX components**.</span></span> <span data-ttu-id="af03a-170">새 MRTK v2를 수집하는 혼합 현실 개발자에게 가장 흔하게 나타나는 충돌은 입력 및 조작과 관련된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-170">The most common and prevalent conflict for a Mixed Reality developer ingesting the new MRTK v2 will involve input and interactions.</span></span> <span data-ttu-id="af03a-171">따라서 먼저 [MRTK v2 입력 모델](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Input/Overview.html)을 읽고 이해하는 것이 중요합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-171">Thus, it is advised to begin reading and understanding the [MRTK v2 input model](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/Input/Overview.html).</span></span>

<span data-ttu-id="af03a-172">마지막으로, 새 MRTK v2는 스크립트 및 장면 내 관리자 개체에서 구성 및 서비스 공급자 아키텍처로 전환되었습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-172">Finally, the new MRTK v2 has transitioned from a model of scripts and in-scene manager objects to a configuration and services provider architecture.</span></span> <span data-ttu-id="af03a-173">이로 인해 보다 명확한 장면 계층 구조 및 아키텍처 모델이 구현되지만, 새로운 구성 프로필을 이해하기 위한 학습 곡선이 필요합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-173">This results in a cleaner scene hierarchy and architecture model but requires a learning curve for understanding the new configuration profiles.</span></span> <span data-ttu-id="af03a-174">따라서 [Mixed Reality Toolkit 구성 가이드](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/MixedRealityConfigurationGuide.html)를 읽어보고 애플리케이션 요구에 맞게 조정해야 하는 중요한 설정 및 프로필에 익숙해지도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-174">Thus, please read the [Mixed Reality Toolkit Configuration Guide](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/MixedRealityConfigurationGuide.html) to start becoming familiar with the important settings and profiles to adjust to the needs of your application.</span></span> 

### <a name="perform-the-migration"></a><span data-ttu-id="af03a-175">마이그레이션 수행</span><span class="sxs-lookup"><span data-stu-id="af03a-175">Perform the migration</span></span>

<span data-ttu-id="af03a-176">MRTK v2를 가져온 후 Unity 프로젝트에서 많은 컴파일러 관련 오류가 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-176">After importing MRTK v2, your Unity project will likely have many compiler related errors.</span></span> <span data-ttu-id="af03a-177">새로운 네임스페이스 구조 및 새로운 구성 요소 이름 때문에 이러한 오류가 발생하는 것이 가장 일반적입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-177">These are most commonly due to the new namespace structure and new component names.</span></span> <span data-ttu-id="af03a-178">새로운 네임스페이스 및 구성 요소에 맞게 스크립트를 수정하여 이러한 오류를 계속 해결합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-178">Proceed to resolve these errors by modifying your scripts to the new namespaces and components.</span></span> 

<span data-ttu-id="af03a-179">HTK/MRTK과 MRTK 버전 2 간의 특정 API 차이점에 대한 자세한 내용은 [MRTK 버전 2 wiki](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/HTKToMRTKPortingGuide.html)의 이식 가이드를 참조하세요.</span><span class="sxs-lookup"><span data-stu-id="af03a-179">For more information on specific API differences between HTK/MRTK and MRTK version 2, see the porting guide on the [MRTK Version 2 wiki](https://microsoft.github.io/MixedRealityToolkit-Unity/Documentation/HTKToMRTKPortingGuide.html).</span></span>

### <a name="best-practices"></a><span data-ttu-id="af03a-180">최선의 구현 방법</span><span class="sxs-lookup"><span data-stu-id="af03a-180">Best practices</span></span>

- <span data-ttu-id="af03a-181">기본적으로 MRTK 표준 셰이더 사용</span><span class="sxs-lookup"><span data-stu-id="af03a-181">Prefer use of the MRTK Standard shader</span></span>
- <span data-ttu-id="af03a-182">한 번에 한 가지 중요 변경 유형 처리(예: IFocusable에서 IMixedRealityFocusHandler로의 변경)</span><span class="sxs-lookup"><span data-stu-id="af03a-182">Work on one breaking change type at a time (ex: IFocusable to IMixedRealityFocusHandler)</span></span>
- <span data-ttu-id="af03a-183">변경할 때마다 테스트하고 소스 제어 활용</span><span class="sxs-lookup"><span data-stu-id="af03a-183">Test after every change and utilize source control</span></span>
- <span data-ttu-id="af03a-184">가능한 경우 기본 MRTK UX(단추, 슬레이트 등) 사용</span><span class="sxs-lookup"><span data-stu-id="af03a-184">Use default MRTK UX (buttons, slates, etc) when possible</span></span>
- <span data-ttu-id="af03a-185">MRTK 파일을 직접 수정하지 않도록 하고, 대신 MRTK 구성 요소에 대해 래퍼 생성</span><span class="sxs-lookup"><span data-stu-id="af03a-185">Try to refrain from modifying MRTK files directly, instead create wrappers around MRTK components</span></span>
    - <span data-ttu-id="af03a-186">이를 통해 향후 MRTK 삽입 및 업데이트로부터 보호</span><span class="sxs-lookup"><span data-stu-id="af03a-186">This will protect against future MRTK ingestions and updates</span></span>
- <span data-ttu-id="af03a-187">MRTK에 제공된 샘플 장면(특히 *HandInteractionExamples.scene*)을 검토 및 탐색</span><span class="sxs-lookup"><span data-stu-id="af03a-187">Review & explore sample scenes provided in MRTK (especially *HandInteractionExamples.scene*)</span></span>
- <span data-ttu-id="af03a-188">대신 quads, colliders 및 TextMeshPro 텍스트를 사용하여 캔버스 기반 UI 다시 빌드</span><span class="sxs-lookup"><span data-stu-id="af03a-188">Rebuild canvas-based UI with quads, colliders and TextMeshPro text instead</span></span>

### <a name="testing-your-application"></a><span data-ttu-id="af03a-189">애플리케이션 테스트</span><span class="sxs-lookup"><span data-stu-id="af03a-189">Testing your application</span></span>

<span data-ttu-id="af03a-190">이제 [RC1](https://github.com/Microsoft/MixedRealityToolkit-Unity/releases/tag/v2.0.0-RC1)부터는 HoloLens 2 구성 요소 및 기능을 MRTK 버전 2에서 사용할 수 있으므로, Unity에서 직접 손 조작을 시뮬레이트하고, 손 조작 및 시선 추적을 위한 새 API를 개발할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-190">Now that HoloLens 2 components and capabilities are available in MRTK version 2, as of [RC1](https://github.com/Microsoft/MixedRealityToolkit-Unity/releases/tag/v2.0.0-RC1), you can simulate the hand interactions directly in Unity, and develop against the new APIs for hand interactions and eye tracking.</span></span>  <span data-ttu-id="af03a-191">HoloLens 2 디바이스는 유용한 환경을 만드는 데 필요하지만, 적어도 도구 및 설명서에서 학습을 시작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-191">The HoloLens 2 device is required to create a great experience, but at least one could start learning in the tools and documentation.</span></span> <span data-ttu-id="af03a-192">또한 MRTK v2는 HoloLens(1세대)에서의 개발을 지원하므로, 에어 탭을 통한 선택과 같은 기존 입력 모델을 HoloLens(1세대) 디바이스에서 여전히 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-192">Further, MRTK v2 supports development on HoloLens (1st gen) and thus, traditional input models such as select via air-tap can still be tested on HoloLens (1st gen) devices.</span></span> 

## <a name="updating-interaction-model-for-hololens-2"></a><span data-ttu-id="af03a-193">HoloLens 2용 조작 모델을 업데이트</span><span class="sxs-lookup"><span data-stu-id="af03a-193">Updating interaction model for HoloLens 2</span></span>

<span data-ttu-id="af03a-194">HoloLens 2를 앱을 이식하고 위해 준비한 경우 조작 모델 및 홀로그램 디자인/배치를 업데이트할 준비가 된 것입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-194">Once you have your app ported and prepped for HoloLens 2, you are ready to consider updating your interaction model and hologram designs/placement.</span></span>
<span data-ttu-id="af03a-195">HoloLens(1세대)에서 가져온 앱은 시야각에 맞도록 홀로그램이 비교적 멀리 떨어져 있는 응시 및 커밋 조작 모델을 사용할 확률이 높습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-195">Coming from HoloLens (1st gen), your app likely has a gaze and commit interaction model, with holograms relatively far away to fit into the field of view.</span></span>

<span data-ttu-id="af03a-196">HoloLens 2에 가장 적합하게 앱 디자인을 업데이트하는 단계:</span><span class="sxs-lookup"><span data-stu-id="af03a-196">Steps to update your app design to be best for HoloLens 2:</span></span>
1.  <span data-ttu-id="af03a-197">MRTK 구성 요소: 사전 작업에 따라, MRTK v2를 추가한 경우 HoloLens 2에 맞게 디자인하고 최적화한 다양한 구성 요소/스크립트를 활용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-197">MRTK components: Per the pre-work, if you added MRTK v2, there are various components/scripts to leverage that have been designed and optimized for HoloLens 2.</span></span>

2.  <span data-ttu-id="af03a-198">조작 모델: 조작 모델을 업데이트하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-198">Interaction model: Consider updating your interaction model.</span></span>  <span data-ttu-id="af03a-199">대부분의 시나리오에서는 응시 및 커밋에서 손 조작으로 전환하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-199">For most scenarios, we recommend switching from gaze and commit to hands.</span></span>  <span data-ttu-id="af03a-200">홀로그램이 일반적으로 손에 닿지 않는 경우 손으로 전환하면 먼 거리 조작 포인팅 레이 및 잡기 제스처가 표시됩니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-200">With your holograms typically being out of arms reach, switching to hands will result in far interaction pointing rays and grab gestures.</span></span>
<span data-ttu-id="af03a-201">참고: 태스크 작업자가 공구를 잡고 있는 경우와 같이 핸즈프리 조작 모델이 필요한 시나리오가 있으며 이러한 경우에 맞는 특정 디자인 지침이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-201">Note: there are scenarios where a hands-free interaction model is required, such as a task worker holding tools, and there is specific design guidance for such cases.</span></span> 

3.  <span data-ttu-id="af03a-202">홀로그램 배치: 손 조작 모델로 전환한 후에는 근거리 조작 잡기 제스처를 사용하여 손으로 홀로그램을 직접 조작하기 위해 일부 홀로그램을 좀 더 가깝게 이동하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-202">Hologram placement: After switching to a hands interaction model, consider moving some holograms closer to directly interact with the holograms with your hands, using near interaction grab gestures.</span></span>  <span data-ttu-id="af03a-203">직접 잡거나 조작하기 위해 좀 더 가깝게 이동하는 것이 바람직한 홀로그램 유형은 홀로그램을 잡고 조작할 때 HoloLens 2 시야각 내에 잘 맞는 작은 대상 메뉴, 컨트롤, 단추 및 더 작은 홀로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-203">The types of holograms recommended to move closer to directly grab or interact are small target menus, controls, buttons, and smaller holograms that fit within the HoloLens 2 field of view when grabbing and inspecting the hologram.</span></span>
<br>
<span data-ttu-id="af03a-204">모든 앱 및 시나리오는 다르며, 피드백 및 지속적인 학습을 토대로 디자인 지침을 계속 조정한 후 게시할 예정입니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-204">Every app and scenario is different, and we’ll continue to refine and post design guidance based on feedback and continued learnings.</span></span>


## <a name="additional-learnings-from-moving-apps-from-x86-to-arm"></a><span data-ttu-id="af03a-205">x86에서 ARM으로 앱을 이동하기 위한 추가 학습</span><span class="sxs-lookup"><span data-stu-id="af03a-205">Additional learnings from moving apps from x86 to ARM</span></span>

- <span data-ttu-id="af03a-206">직선 Unity 앱은 단순하므로 ARM appx 번들을 빌드하거나 디바이스에 직접 배포한 후 실행할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-206">Straight Unity apps are simple as you can build an ARM appx bundle or deploy directly to the device and it runs.</span></span>
<span data-ttu-id="af03a-207">문제는 Unity 앱이 기본 플러그 인을 사용할 때 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-207">The challenge comes when the Unity app uses native plugins.</span></span>  <span data-ttu-id="af03a-208">모든 기본 플러그 인은 VS2017로 업그레이드하고, ARM용으로, Unity 2019를 사용할 때는 ARM64용으로 다시 빌드해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-208">All of the native plugins need to be upgraded to VS2017 and rebuilt for ARM, and with Unity 2019, ARM64.</span></span>

- <span data-ttu-id="af03a-209">하나의 앱이 Unity용 AudioKinetic Wwise 플러그 인을 사용했으며 사용된 버전에는 UWP ARM 플러그 인이 없었습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-209">One app, used the AudioKinetic Wwise plugin for Unity, and the version used didn’t have a UWP ARM plugin.</span></span> <span data-ttu-id="af03a-210">애플리케이션의 소리가 ARM에서 작동하는 데 며칠이 걸렸습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-210">It took several days to re-work the sound in the application to work on ARM.</span></span>

- <span data-ttu-id="af03a-211">또 다른 경우에서 앱 필수 플러그 인에 대해 UWP/ARM 플러그 인이 존재하지 않아 HoloLens 2에서 이식 및 실행하지 못할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-211">In other cases, a UWP/ARM plugin may not exist for app-required plugins, blocking the ability to port and run on HoloLens 2.</span></span>  <span data-ttu-id="af03a-212">ARM을 차단 해제하고 지원하기 위해 플러그 인 공급자와 계약해야 할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-212">Engagement with the plugin provider may be needed to unblock and support ARM.</span></span>

- <span data-ttu-id="af03a-213">셰이더의 minfloat(및 min16float, minint 등의 변형)은 HoloLen 2에서 HoloLens(1세대)와는 다르게 동작할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-213">The minfloat (and variants such as min16float, minint, etc…) in shaders may behave differently on HoloLen 2 than on HoloLens (1st gen).</span></span> <span data-ttu-id="af03a-214">특히, “적어도 지정된 수의 비트가 사용될 수 있습니다.”</span><span class="sxs-lookup"><span data-stu-id="af03a-214">Specifically, these guarantee that “at least the specified number of bits will be used”.</span></span> <span data-ttu-id="af03a-215">Intel/Nvidia GPU에서는 대체적으로 32비트로 처리됩니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-215">On Intel/Nvidia GPUs, these are largely just treated as 32 bits.</span></span> <span data-ttu-id="af03a-216">ARM에서는 지정된 비트 수가 실제로 적용됩니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-216">On ARM, the number of bits specified is actually respected.</span></span> <span data-ttu-id="af03a-217">즉, 실제로 이러한 수는 HoloLens(1세대)의 경우보다 HoloLens 2에서 전체 자릿수/범위가 더 적을 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-217">That means that in practice, these numbers may have less precision/range on HoloLens 2 than they did on HoloLens (1st gen).</span></span>

- <span data-ttu-id="af03a-218">_asm 명령은 ARM에서 작동하지 않는 것처럼 나타납니다. 즉, _asm 명령을 사용하는 모든 코드는 다시 작성해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-218">The _asm instructions don’t appear to work on ARM, meaning any code using _asm instructions will have to be rewritten.</span></span>

- <span data-ttu-id="af03a-219">SIMD 명령 집합은 ARM에서 지원되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-219">The SIMD instruction set is not supported on ARM.</span></span> <span data-ttu-id="af03a-220">즉, xmmintrin.h, emmintrin.h, tmmintrin.h 및 immintrin.h와 같은 다양한 헤더를 ARM에서 사용할 수 없습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-220">This means various headers, such as xmmintrin.h, emmintrin.h, tmmintrin.h, and immintrin.h are not available on ARM.</span></span>

- <span data-ttu-id="af03a-221">ARM의 셰이더 컴파일러는 셰이더 로드 타임이 아니라, 셰이더가 로드되었거나 셰이더가 의존하는 대상이 변경된 이후의 첫 번째 그리기 호출 동안 실행됩니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-221">The shader compiler on ARM runs during the first draw call after the shader has been loaded or something the shader relies on has changed, not at shader load time.</span></span> <span data-ttu-id="af03a-222">프레임 속도에 미치는 영향은 컴파일해야 하는 셰이더 수에 따라 매우 확실하게 나타날 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-222">The impact on framerate can be very noticeable, depending on how many shaders need to be compiled.</span></span> <span data-ttu-id="af03a-223">따라서 셰이더를 HoloLens 2와 HoloLens(1세대)에서 다른 방식으로 처리/패키지/업데이트해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="af03a-223">This has various implications for how shaders should be handled/packaged/updated differently on HoloLens 2 vs HoloLens (1st gen).</span></span>

## <a name="see-also"></a><span data-ttu-id="af03a-224">참고 항목</span><span class="sxs-lookup"><span data-stu-id="af03a-224">See also</span></span>
* [<span data-ttu-id="af03a-225">MRTK 버전 2 시작</span><span class="sxs-lookup"><span data-stu-id="af03a-225">Getting started with MRTK version 2</span></span>](mrtk-getting-started.md)
* [<span data-ttu-id="af03a-226">MRTK 버전 2 HowTo</span><span class="sxs-lookup"><span data-stu-id="af03a-226">MRTK Version 2 HowTo</span></span>](https://microsoft.github.io/MixedRealityToolkit-Unity/External/HowTo/README.html)
* [<span data-ttu-id="af03a-227">도구 설치</span><span class="sxs-lookup"><span data-stu-id="af03a-227">Install the tools</span></span>](install-the-tools.md)
* [<span data-ttu-id="af03a-228">Unity 권장 설정</span><span class="sxs-lookup"><span data-stu-id="af03a-228">Recommended settings for Unity</span></span>](recommended-settings-for-unity.md)
* [<span data-ttu-id="af03a-229">혼합 현실의 성능 이해</span><span class="sxs-lookup"><span data-stu-id="af03a-229">Understanding performance for Mixed Reality</span></span>](understanding-performance-for-mixed-reality.md)

