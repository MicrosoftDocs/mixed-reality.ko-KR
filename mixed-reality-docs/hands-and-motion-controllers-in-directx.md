---
title: 실습 및 DirectX에서 컨트롤러 동작
description: 네이티브 DirectX 앱에서 직접 추적 및 동작 컨트롤러를 사용 하기 위한 개발자 가이드입니다.
author: caseymeekhof
ms.author: cmeekhof
ms.date: 04/30/2019
ms.topic: article
keywords: 실습, 동작 컨트롤러, directx, 입력, 홀로그램
ms.openlocfilehash: 08666c8c26cd4851c0c003a96a9e96d7a90228ac
ms.sourcegitcommit: 45676da11ebe33a2aa3dccec0e8ad7d714420853
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/15/2019
ms.locfileid: "65629646"
---
# <a name="hands-and-motion-controllers-in-directx"></a><span data-ttu-id="3c14c-104">실습 및 DirectX에서 컨트롤러 동작</span><span class="sxs-lookup"><span data-stu-id="3c14c-104">Hands and motion controllers in DirectX</span></span>

<span data-ttu-id="3c14c-105">Windows Mixed Reality에 모두 전달 및 [동작 컨트롤러](motion-controllers.md) 입력에서 찾을 공간 입력 Api 통해 처리 됩니다 합니다 [Windows.UI.Input.Spatial](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial) 네임 스페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-105">In Windows Mixed Reality, both hand and [motion controller](motion-controllers.md) input is handled through the spatial input APIs, found in the [Windows.UI.Input.Spatial](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial) namespace.</span></span> <span data-ttu-id="3c14c-106">쉽게 등의 일반적인 작업을 처리할 수 있습니다 **선택** 실습 및 동작 컨트롤러 모두에서 동일한 방식으로 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-106">This enables you to easily handle common actions like **Select** presses the same way across both hands and motion controllers.</span></span>

## <a name="getting-started"></a><span data-ttu-id="3c14c-107">시작</span><span class="sxs-lookup"><span data-stu-id="3c14c-107">Getting started</span></span>

<span data-ttu-id="3c14c-108">액세스에 공간에서 Windows Mixed Reality 입력 SpatialInteractionManager 인터페이스를 사용 하 여 시작 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-108">To access spatial input in Windows Mixed Reality, start with the SpatialInteractionManager interface.</span></span>  <span data-ttu-id="3c14c-109">이 인터페이스를 호출 하 여 액세스할 수 있습니다 [SpatialInteractionManager::GetForCurrentView](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getforcurrentview), 일반적으로 앱 시작 시 따라 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-109">You can access this interface by calling  [SpatialInteractionManager::GetForCurrentView](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getforcurrentview), typically sometime during app startup.</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

SpatialInteractionManager interactionManager = SpatialInteractionManager::GetForCurrentView();
```

<span data-ttu-id="3c14c-110">SpatialInteractionManager의 작업에 대 한 액세스를 제공 하는 것 [SpatialInteractionSources](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource), 입력 소스를 나타내는입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-110">The SpatialInteractionManager's job is to provide access to [SpatialInteractionSources](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource), which represent a source of input.</span></span>  <span data-ttu-id="3c14c-111">세 가지 종류의 SpatialInteractionSources 시스템에서 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-111">There are three kinds of SpatialInteractionSources available in the system.</span></span>
* <span data-ttu-id="3c14c-112">**직접** 사용자의 검색 된 직접 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-112">**Hand** represents a user's detected hand.</span></span> <span data-ttu-id="3c14c-113">직접 원본 HoloLens에 기본 제스처에서 완전히 표시 된 직접 HoloLens 2에서 추적에 이르기까지, 장치에 따라 다양 한 기능을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-113">Hand sources offer different features based on the device, ranging from basic gestures on HoloLens to fully articulated hand tracking on HoloLens 2.</span></span> 
* <span data-ttu-id="3c14c-114">**컨트롤러** 쌍을 이루는 동작 컨트롤러를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-114">**Controller** represents a paired motion controller.</span></span> <span data-ttu-id="3c14c-115">동작 컨트롤러는 다양 한 기능을 제공할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-115">Motion controllers can offer a variety of capabilities.</span></span>  <span data-ttu-id="3c14c-116">예를 들어 다음과 같은 가치를 제공해야 합니다. 트리거, 메뉴 단추, 감각을 단추, 터치 패드 및 스틱을 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-116">For example: Select triggers, Menu buttons, Grasp buttons, touchpads and thumbsticks.</span></span>
* <span data-ttu-id="3c14c-117">**음성** 사용자의 음성 말하기 시스템 검색 키워드를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-117">**Voice** represents the user's voice speaking system-detected keywords.</span></span> <span data-ttu-id="3c14c-118">예를 들어,이 소스를 삽입 된 선택 키를 눌러 사용자가 "Select" 때마다 릴리스 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-118">For example, this source will inject a Select press and release whenever the user says "Select".</span></span>

<span data-ttu-id="3c14c-119">프레임당 데이터 원본으로 표시 됩니다에 대 한 합니다 [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) 인터페이스입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-119">Per-frame data for a source is represented by the  [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) interface.</span></span> <span data-ttu-id="3c14c-120">응용 프로그램에서 이벤트 구동 또는 폴링 기반 모델을 사용할 것인지에 따라이 데이터에 액세스 하려면 두 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-120">There are two different ways to access this data, depending on whether you want to use an event-driven or polling-based model in your application.</span></span>

### <a name="event-driven-input"></a><span data-ttu-id="3c14c-121">이벤트 기반 입력</span><span class="sxs-lookup"><span data-stu-id="3c14c-121">Event-driven input</span></span>
<span data-ttu-id="3c14c-122">SpatialInteractionManager 수의 앱에 대 한 수신 대기할 수 있는 이벤트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-122">The SpatialInteractionManager provides a number of events that your app can listen for.</span></span>  <span data-ttu-id="3c14c-123">몇 가지 예로 [SourcePressed](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed)하십시오 [SourceReleased](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) 하 고 [SourceUpdated](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-123">A few examples include   [SourcePressed](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed), [SourceReleased](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) and [SourceUpdated](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated).</span></span>

<span data-ttu-id="3c14c-124">예를 들어, 다음 코드를 MyApp::OnSourcePressed SourcePressed 이벤트를 호출 하는 이벤트 처리기를 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-124">For example, the following code hooks up an event handler called MyApp::OnSourcePressed to the SourcePressed event.</span></span>  <span data-ttu-id="3c14c-125">이 앱을을 누르면 모든 종류의 상호 작용 원본에서 검색할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-125">This allows your app to detect presses on any type of interaction source.</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

auto interactionManager = SpatialInteractionManager::GetForCurrentView();
interactionManager.SourcePressed({ this, &MyApp::OnSourcePressed });

```

<span data-ttu-id="3c14c-126">누름된이 이벤트는 눌러 발생 시 해당 SpatialInteractionSourceState 함께 비동기적으로 앱에 전송 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-126">This pressed event is sent to your app asynchronously, along with the corresponding SpatialInteractionSourceState at the time the press happened.</span></span> <span data-ttu-id="3c14c-127">앱 또는 게임 엔진은 일부 처리를 즉시 수행 해야 할 수 또는 처리 루틴 입력에서 이벤트 데이터를 큐에 대기 하는 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-127">Your app or game engine may want to perform some processing right away or you may want to queue up the event data in your input processing routine.</span></span> <span data-ttu-id="3c14c-128">선택 단추를 눌렀는지 여부를 확인 하는 방법을 보여 주는 SourcePressed 이벤트에 대 한 이벤트 처리기 함수는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-128">Here is an event handler function for the SourcePressed event, which shows how to check whether the select button was pressed.</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

void MyApp::OnSourcePressed(SpatialInteractionManager const& sender, SpatialInteractionSourceEventArgs const& args)
{
    if (args.PressKind() == SpatialInteractionPressKind::Select)
    {
        // Select button was pressed, update app state
    }
}
```

<span data-ttu-id="3c14c-129">위의 코드는 장치에서 기본 작업에 해당 하는 'Select' press만 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-129">The above code only checks for the 'Select' press, which corresponds to the primary action on the device.</span></span> <span data-ttu-id="3c14c-130">HoloLens에는 AirTap 수행 또는 동작 컨트롤러에서 트리거를 끌어오기을 예로 들 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-130">Examples include doing an AirTap on HoloLens or pulling the trigger on a motion controller.</span></span>  <span data-ttu-id="3c14c-131">'Select' 누름 대상으로 하는 홀로그램을 활성화 하려면 사용자의 의도를 나타냅니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-131">'Select' presses represent the user's intention to activate the hologram they are targeting.</span></span>  <span data-ttu-id="3c14c-132">다양 한 다른 단추와 제스처에 대 한이 SourcePressed 이벤트가 발생 합니다 하 고 테스트 사례만 SpatialInteractionSource의 다른 속성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-132">The SourcePressed event will fire for a number of different buttons and gestures, and you can inspect other properties on the SpatialInteractionSource to test for those cases.</span></span>

### <a name="polling-based-input"></a><span data-ttu-id="3c14c-133">폴링 기반 입력</span><span class="sxs-lookup"><span data-stu-id="3c14c-133">Polling-based input</span></span>
<span data-ttu-id="3c14c-134">입력의 현재 상태에 대 한 모든 프레임을 폴링할 SpatialInteractionManager 이용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-134">You can also use SpatialInteractionManager to poll for the current state of input every frame.</span></span>  <span data-ttu-id="3c14c-135">이렇게 하려면 단순히 호출 [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) 프레임 마다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-135">To do this, simply call [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) every frame.</span></span>  <span data-ttu-id="3c14c-136">이 함수 하나를 포함 하는 배열을 반환 [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) 모든 활성 [SpatialInteractionSource](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-136">This function returns an array containing one [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) for every active [SpatialInteractionSource](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource).</span></span> <span data-ttu-id="3c14c-137">즉, 각 활성 동작 컨트롤러, 각 추적 된 포인터에 대 한 음성에 대 한 'select' 명령을 최근에 마냥 마음이 들 뜹니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-137">This means one for each active motion controller, one for each tracked hand, and one for speech if a 'select' command was recently uttered.</span></span> <span data-ttu-id="3c14c-138">그런 다음 응용 프로그램에 각 SpatialInteractionSourceState 드라이브 입력에 대 한 속성을 검사할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-138">You can then inspect the properties on each SpatialInteractionSourceState to drive input into your application.</span></span> 

<span data-ttu-id="3c14c-139">폴링 메서드를 사용 하는 'select' 작업에 대 한 확인 하는 방법의 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-139">Here is an example of how to check for the 'select' action using the polling method.</span></span> <span data-ttu-id="3c14c-140">*예측* 변수를 나타냅니다는 [HolographicFramePrediction](https://docs.microsoft.com/en-us/uwp/api/Windows.Graphics.Holographic.HolographicFramePrediction) 에서 가져올 수 있는 개체를 [HolographicFrame](https://docs.microsoft.com/en-us/uwp/api/windows.graphics.holographic.holographicframe)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-140">Note that the *prediction* variable represents a [HolographicFramePrediction](https://docs.microsoft.com/en-us/uwp/api/Windows.Graphics.Holographic.HolographicFramePrediction) object, which can be obtained from the [HolographicFrame](https://docs.microsoft.com/en-us/uwp/api/windows.graphics.holographic.holographicframe).</span></span>

```cpp
using namespace winrt::Windows::UI::Input::Spatial;

auto interactionManager = SpatialInteractionManager::GetForCurrentView();
auto sourceStates = m_spatialInteractionManager.GetDetectedSourcesAtTimestamp(prediction.Timestamp());

for (auto& sourceState : sourceStates)
{
    if (sourceState.IsSelectPressed())
    {
        // Select button is down, update app state
    }
}
```

<span data-ttu-id="3c14c-141">각 SpatialInteractionSource에 새 소스를 식별 하 고 기존 원본 프레임 간에 상관 관계를 지정 하는 데 사용할 수 있는 ID가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-141">Each SpatialInteractionSource has an ID, which you can use to identify new sources and correlate existing sources from frame to frame.</span></span>  <span data-ttu-id="3c14c-142">실습은 컨트롤러 Id는 세션의 기간 동안 정적 상태로 유지 되지만 유지 하며, FOV 입력 때마다 새 ID는 할당 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-142">Hands are assigned a new ID every time they leave and enter the FOV, but controller IDs remain static for the duration of the session.</span></span>  <span data-ttu-id="3c14c-143">SpatialInteractionManager에서와 같은 이벤트를 사용할 수 [SourceDetected](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcedetected) 하 고 [SourceLost](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcelost), 실습을 입력 하거나 장치를 유지 하는 경우 반응의 보기 또는 동작 컨트롤러 켜고 설정 또는 경우 쌍을 이루는/짝이 없는 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-143">You can use the events on SpatialInteractionManager such as [SourceDetected](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcedetected) and [SourceLost](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcelost), to react when hands enter or leave the device's view, or when motion controllers are turned on/off or are paired/unpaired.</span></span>

### <a name="predicted-vs-historical-poses"></a><span data-ttu-id="3c14c-144">기록 포즈 및 예측</span><span class="sxs-lookup"><span data-stu-id="3c14c-144">Predicted vs. historical poses</span></span>
<span data-ttu-id="3c14c-145">GetDetectedSourcesAtTimestamp 타임 스탬프 매개 변수는 참고 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-145">Note that GetDetectedSourcesAtTimestamp has a timestamp parameter.</span></span> <span data-ttu-id="3c14c-146">이렇게 하면 상태를 요청 하 고 예측 하거나 데이터를 내포할 수 있습니다 또는 다른 입력 소스를 사용 하 여 공간 상호 작용을 상호 연결 기록, 하도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-146">This enables you to request state and pose data that is either predicted or historical, letting you correlate spatial interactions with other sources of input.</span></span> <span data-ttu-id="3c14c-147">예를 들어, 현재 프레임에 손 모양 아이콘이 위치를 렌더링할 때 전달할 수 있습니다 제공한 예측된 타임 스탬프를 [HolographicFrame](https://docs.microsoft.com/en-us/uwp/api/windows.graphics.holographic.holographicframe)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-147">For example, when rendering the hand's position in the current frame, you can pass in the predicted timestamp provided by the [HolographicFrame](https://docs.microsoft.com/en-us/uwp/api/windows.graphics.holographic.holographicframe).</span></span> <span data-ttu-id="3c14c-148">따라서 시스템 정방향 예측 체감된 대기 시간을 최소화 렌더링 된 프레임 출력을 사용 하 여 맞추려는 직접 위치에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-148">This enables the system to forward-predict the hand position to closely align with the rendered frame output, minimizing perceived latency.</span></span>

<span data-ttu-id="3c14c-149">그러나 예측된 포즈 이러한를 상호 작용 원본을 사용 하 여 대상으로 하는 이상적인 포인팅 광선을 생성 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-149">However, such a predicted pose does not produce an ideal pointing ray for targeting with an interaction source.</span></span> <span data-ttu-id="3c14c-150">예를 들어 컨트롤러 동작 단추를 누를 때 운영 체제에 Bluetooth를 통해 버블 업 이벤트에 대 한 최대 20ms 걸릴 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-150">For example, when a motion controller button is pressed, it can take up to 20ms for that event to bubble up through Bluetooth to the operating system.</span></span> <span data-ttu-id="3c14c-151">마찬가지로, 손 제스처를 수행 하면, 어느 정도의 시간 시스템 제스처를 감지 하는 앱 다음에 대 한 폴링합니다 전에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-151">Similarly, after a user performs a hand gesture, some amount of time may pass before the system detects the gesture and your app then polls for it.</span></span> <span data-ttu-id="3c14c-152">상태 변경에 대 한 앱 폴링합니다 시간, 헤드 및 직접 발생 대상 과거에 실제로 발생 한 상호 작용 하는 데 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-152">By the time your app polls for a state change, the head and hand poses used to target that interaction actually happened in the past.</span></span> <span data-ttu-id="3c14c-153">GetDetectedSourcesAtTimestamp를 현재 프로그램 HolographicFrame의 타임 스탬프를 전달 하 여 대상 포즈 됩니다 대신 앞으로 예측할 수 타기 팅 광선을 프레임을 표시할 때 나중에 20ms 둘 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-153">If you target by passing your current HolographicFrame's timestamp to GetDetectedSourcesAtTimestamp, the pose will instead be forward predicted to the targeting ray at the time the frame will be displayed, which could be more than 20ms in the future.</span></span> <span data-ttu-id="3c14c-154">이 향후 포즈 적합 *렌더링* 상호 작용 원본에 대 한 시간 문제를 하지만 않았을 *대상으로* 과거에 발생 사용자의 대상으로 하는 대로 상호 작용을 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-154">This future pose is good for *rendering* the interaction source, but compounds our time problem for *targeting* the interaction, as the user's targeting occurred in the past.</span></span>

<span data-ttu-id="3c14c-155">다행 스럽게도 합니다 [SourcePressed](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed)를 [SourceReleased](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) 및 [SourceUpdated](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated) 이벤트를 기록 제공 [상태](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) 연관 각 입력된 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-155">Fortunately, the [SourcePressed](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed), [SourceReleased](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) and [SourceUpdated](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourceupdated) events provide the historical [State](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) associated with each input event.</span></span>  <span data-ttu-id="3c14c-156">직접 포함 되어이 통해 사용할 수 있는 기록 헤드 및 직접 발생 [TryGetPointerPose](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose), 기록를 함께 [타임 스탬프](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.timestamp) 이 이벤트와 연결할 다른 Api에 전달할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-156">This directly includes the historical head and hand poses available through [TryGetPointerPose](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose), along with a historical [Timestamp](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.timestamp) that you can pass to other APIs to correlate with this event.</span></span>

<span data-ttu-id="3c14c-157">렌더링 하 고 각 프레임의 실습 및 컨트롤러를 사용 하 여 대상으로 하는 경우 다음 모범 사례에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-157">That leads to the following best practices when rendering and targeting with hands and controllers each frame:</span></span>
* <span data-ttu-id="3c14c-158">에 대 한 **손/컨트롤러 렌더링** 앱 해야 하는 각 프레임 **폴링** 에 대 한 합니다 **정방향 예측** 현재 프레임의 photon 시 각 상호 작용 원본의 발생할 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-158">For **hand/controller rendering** each frame, your app should **poll** for the **forward-predicted** pose of each interaction source at the current frame’s photon time.</span></span>  <span data-ttu-id="3c14c-159">호출 하 여 모든 상호 작용 원본에 대해 폴링하면 [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) 제공한 예측된 타임 스탬프를 전달 하는 각 프레임을 [HolographicFrame::CurrentPrediction](https://docs.microsoft.com/en-us/uwp/api/windows.graphics.holographic.holographicframe.currentprediction)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-159">You can poll for all interaction sources by calling [GetDetectedSourcesAtTimestamp](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.getdetectedsourcesattimestamp) each frame, passing in the predicted timestamp provided by [HolographicFrame::CurrentPrediction](https://docs.microsoft.com/en-us/uwp/api/windows.graphics.holographic.holographicframe.currentprediction).</span></span>
* <span data-ttu-id="3c14c-160">에 대 한 **손/컨트롤러를 대상으로 하** 누르거나 릴리스 시 앱 눌렀다 해제 처리 해야 **이벤트**, 플레이어가 기반으로 합니다 **기록** 에 대 한 헤드 또는 직접 자세 해당 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-160">For **hand/controller targeting** upon a press or release, your app should handle pressed/released **events**, raycasting based on the **historical** head or hand pose for that event.</span></span> <span data-ttu-id="3c14c-161">처리 하 여이 대상 광선을 얻게 합니다 [SourcePressed](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed) 또는 [SourceReleased](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) 이벤트를 시작 합니다 [상태](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) 속성에서 이벤트 인수를 호출한 다음 해당 [ TryGetPointerPose](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose) 메서드.</span><span class="sxs-lookup"><span data-stu-id="3c14c-161">You get this targeting ray by handling the [SourcePressed](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcepressed) or [SourceReleased](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionmanager.sourcereleased) event, getting the [State](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourceeventargs.state) property from the event arguments, and then calling its [TryGetPointerPose](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygetpointerpose) method.</span></span>

## <a name="cross-device-input-properties"></a><span data-ttu-id="3c14c-162">장치 간 입력된 속성</span><span class="sxs-lookup"><span data-stu-id="3c14c-162">Cross-device input properties</span></span>
<span data-ttu-id="3c14c-163">SpatialInteractionSource API 컨트롤러와 직접 추적 기능의 광범위 한를 사용 하 여 시스템을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-163">The SpatialInteractionSource API supports controllers and hand tracking systems with a wide range of capabilities.</span></span> <span data-ttu-id="3c14c-164">이러한 기능을 수는 장치 유형 간에 공통적입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-164">A number of these capabilities are common between device types.</span></span> <span data-ttu-id="3c14c-165">예를 들어, 직접 추적 및 동작 컨트롤러 모두에 'select' 작업을 및 3D 위치를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-165">For example, hand tracking and motion controllers both provide a 'select' action and a 3D position.</span></span> <span data-ttu-id="3c14c-166">가능 하면 API는 SpatialInteractionSource에서 동일한 속성에 이러한 일반적인 기능을 매핑합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-166">Wherever possible, the API maps these common capabilities to the same properties on the SpatialInteractionSource.</span></span>  <span data-ttu-id="3c14c-167">이 통해 응용 프로그램을 보다 쉽게 다양 한 입력된 형식 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-167">This enables applications to more easily support a wide range of input types.</span></span> <span data-ttu-id="3c14c-168">다음 표에서 지원 되는 속성을 설명 하 고 입력된 형식 간에 어떻게 다른 지 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-168">The following table describes the properties that are supported, and how they compare across input types.</span></span>

| <span data-ttu-id="3c14c-169">속성</span><span class="sxs-lookup"><span data-stu-id="3c14c-169">Property</span></span> | <span data-ttu-id="3c14c-170">설명</span><span class="sxs-lookup"><span data-stu-id="3c14c-170">Description</span></span> | <span data-ttu-id="3c14c-171">HoloLens 제스처</span><span class="sxs-lookup"><span data-stu-id="3c14c-171">HoloLens Gestures</span></span> | <span data-ttu-id="3c14c-172">컨트롤러 동작</span><span class="sxs-lookup"><span data-stu-id="3c14c-172">Motion Controllers</span></span> | <span data-ttu-id="3c14c-173">명확 하 고 실습</span><span class="sxs-lookup"><span data-stu-id="3c14c-173">Articulated Hands</span></span>|
|--- |--- |--- |--- |--- |
| [<span data-ttu-id="3c14c-174">SpatialInteractionSource::**선호도**</span><span class="sxs-lookup"><span data-stu-id="3c14c-174">SpatialInteractionSource::**Handedness**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource.handedness) | <span data-ttu-id="3c14c-175">오른쪽 또는 왼쪽 / 컨트롤러입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-175">Right or left hand / controller.</span></span> | <span data-ttu-id="3c14c-176">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="3c14c-176">Not Supported</span></span> | <span data-ttu-id="3c14c-177">지원됨</span><span class="sxs-lookup"><span data-stu-id="3c14c-177">Supported</span></span> | <span data-ttu-id="3c14c-178">지원됨</span><span class="sxs-lookup"><span data-stu-id="3c14c-178">Supported</span></span> |
| [<span data-ttu-id="3c14c-179">SpatialInteractionSourceState::**IsSelectPressed**</span><span class="sxs-lookup"><span data-stu-id="3c14c-179">SpatialInteractionSourceState::**IsSelectPressed**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.isselectpressed) | <span data-ttu-id="3c14c-180">기본 단추의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-180">Current state of the primary button.</span></span> | <span data-ttu-id="3c14c-181">어 탭</span><span class="sxs-lookup"><span data-stu-id="3c14c-181">Air Tap</span></span> | <span data-ttu-id="3c14c-182">트리거</span><span class="sxs-lookup"><span data-stu-id="3c14c-182">Trigger</span></span> | <span data-ttu-id="3c14c-183">완화 된 어 탭 (수직 축소)</span><span class="sxs-lookup"><span data-stu-id="3c14c-183">Relaxed Air Tap (upright pinch)</span></span> |
| [<span data-ttu-id="3c14c-184">SpatialInteractionSourceState::**IsGrasped**</span><span class="sxs-lookup"><span data-stu-id="3c14c-184">SpatialInteractionSourceState::**IsGrasped**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.isgrasped) | <span data-ttu-id="3c14c-185">잡기 단추의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-185">Current state of the grab button.</span></span> | <span data-ttu-id="3c14c-186">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="3c14c-186">Not Supported</span></span> | <span data-ttu-id="3c14c-187">단추를 선택 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-187">Grab button</span></span> | <span data-ttu-id="3c14c-188">축소 또는 닫힌 직접</span><span class="sxs-lookup"><span data-stu-id="3c14c-188">Pinch or Closed Hand</span></span> |
| [<span data-ttu-id="3c14c-189">SpatialInteractionSourceState::**IsMenuPressed**</span><span class="sxs-lookup"><span data-stu-id="3c14c-189">SpatialInteractionSourceState::**IsMenuPressed**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.ismenupressed) | <span data-ttu-id="3c14c-190">메뉴 단추의 현재 상태입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-190">Current state of the menu button.</span></span>    | <span data-ttu-id="3c14c-191">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="3c14c-191">Not Supported</span></span> | <span data-ttu-id="3c14c-192">메뉴 단추</span><span class="sxs-lookup"><span data-stu-id="3c14c-192">Menu Button</span></span> | <span data-ttu-id="3c14c-193">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="3c14c-193">Not Supported</span></span> |
| [<span data-ttu-id="3c14c-194">SpatialInteractionSourceLocation::**Position**</span><span class="sxs-lookup"><span data-stu-id="3c14c-194">SpatialInteractionSourceLocation::**Position**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation.position) | <span data-ttu-id="3c14c-195">컨트롤러에서 직접 또는 그립 위치의 XYZ 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-195">XYZ location of the hand or grip position on the controller.</span></span> | <span data-ttu-id="3c14c-196">팜 위치</span><span class="sxs-lookup"><span data-stu-id="3c14c-196">Palm location</span></span> | <span data-ttu-id="3c14c-197">그립 포즈 위치</span><span class="sxs-lookup"><span data-stu-id="3c14c-197">Grip pose position</span></span> | <span data-ttu-id="3c14c-198">팜 위치</span><span class="sxs-lookup"><span data-stu-id="3c14c-198">Palm location</span></span> |
| [<span data-ttu-id="3c14c-199">SpatialInteractionSourceLocation::**Orientation**</span><span class="sxs-lookup"><span data-stu-id="3c14c-199">SpatialInteractionSourceLocation::**Orientation**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation.orientation) | <span data-ttu-id="3c14c-200">컨트롤러에서 직접 또는 그립 포즈의 방향을 나타내는 쿼터 니 언입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-200">Quaternion representing the orientation of the hand or grip pose on the controller.</span></span> | <span data-ttu-id="3c14c-201">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="3c14c-201">Not Supported</span></span> | <span data-ttu-id="3c14c-202">그립 포즈 방향</span><span class="sxs-lookup"><span data-stu-id="3c14c-202">Grip pose orientation</span></span> | <span data-ttu-id="3c14c-203">Palm 방향</span><span class="sxs-lookup"><span data-stu-id="3c14c-203">Palm orientation</span></span> |
| [<span data-ttu-id="3c14c-204">SpatialPointerInteractionSourcePose::**Position**</span><span class="sxs-lookup"><span data-stu-id="3c14c-204">SpatialPointerInteractionSourcePose::**Position**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialpointerinteractionsourcepose.position#Windows_UI_Input_Spatial_SpatialPointerInteractionSourcePose_Position) | <span data-ttu-id="3c14c-205">포인팅 광선의 원점입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-205">Origin of the pointing ray.</span></span> | <span data-ttu-id="3c14c-206">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="3c14c-206">Not Supported</span></span> | <span data-ttu-id="3c14c-207">지원됨</span><span class="sxs-lookup"><span data-stu-id="3c14c-207">Supported</span></span> | <span data-ttu-id="3c14c-208">지원됨</span><span class="sxs-lookup"><span data-stu-id="3c14c-208">Supported</span></span> |
| [<span data-ttu-id="3c14c-209">SpatialPointerInteractionSourcePose::**ForwardDirection**</span><span class="sxs-lookup"><span data-stu-id="3c14c-209">SpatialPointerInteractionSourcePose::**ForwardDirection**</span></span>](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialpointerinteractionsourcepose.forwarddirection#Windows_UI_Input_Spatial_SpatialPointerInteractionSourcePose_ForwardDirection) | <span data-ttu-id="3c14c-210">포인팅 광선의 방향입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-210">Direction of the pointing ray.</span></span> | <span data-ttu-id="3c14c-211">지원되지 않음</span><span class="sxs-lookup"><span data-stu-id="3c14c-211">Not Supported</span></span> | <span data-ttu-id="3c14c-212">지원됨</span><span class="sxs-lookup"><span data-stu-id="3c14c-212">Supported</span></span> | <span data-ttu-id="3c14c-213">지원됨</span><span class="sxs-lookup"><span data-stu-id="3c14c-213">Supported</span></span> |

<span data-ttu-id="3c14c-214">위의 속성 중 일부를 모든 장치에서 사용할 수 없는 및 API를 통해이 테스트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-214">Some of the above properties are not available on all devices, and the API provides a means to test for this.</span></span> <span data-ttu-id="3c14c-215">예를 들어, 검사할 수 있습니다 합니다 [SpatialInteractionSource::IsGraspSupported](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource.isgraspsupported) 원본 감각을 동작을 제공 하는지 여부를 결정 하는 속성입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-215">For example, you can inspect the [SpatialInteractionSource::IsGraspSupported](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource.isgraspsupported) property to determine whether the source provides a grasp action.</span></span>

### <a name="grip-pose-vs-pointing-pose"></a><span data-ttu-id="3c14c-216">그립 포즈 포인팅 포즈 비교</span><span class="sxs-lookup"><span data-stu-id="3c14c-216">Grip pose vs. pointing pose</span></span>

<span data-ttu-id="3c14c-217">Windows Mixed Reality 다양 한 폼 팩터 동작 컨트롤러를 지원합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-217">Windows Mixed Reality supports motion controllers in a variety of form factors.</span></span>  <span data-ttu-id="3c14c-218">또한 명확 하 고 직접 추적 시스템을 지원 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-218">It also supports articulated hand tracking systems.</span></span>  <span data-ttu-id="3c14c-219">이러한 모든 시스템 손 모양 위치 및 앱에서 사용자의 직접 가리키는 또는 rendreing 개체에 대해 사용 해야 하는 "정방향" 방향 간의 여러 관계를 가집니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-219">All of these systems have different relationships between the hand position and the natural "forward" direction that apps should use for pointing or rendreing objects in the user's hand.</span></span>  <span data-ttu-id="3c14c-220">이 지원 하려면 두 가지 유형의 직접 추적 및 동작 컨트롤러 모두에 대해 제공 하는 3D 포즈 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-220">To support all of this, there are two types of 3D poses provided for both hand tracking and motion controllers.</span></span>  <span data-ttu-id="3c14c-221">첫 번째는 사용자의 직접 위치를 나타내는 그립 자세 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-221">The first is grip pose, which represents the user's hand position.</span></span>  <span data-ttu-id="3c14c-222">두 번째는 사용자의 직접 또는 컨트롤러에서 시작 되는 포인팅 빛을 나타내는 자세를 가리킵니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-222">The second is pointing pose, which represents a pointing ray originating from the user's hand or controller.</span></span> <span data-ttu-id="3c14c-223">따라서 렌더링 하려는 경우 **사용자의 직접** 또는 **사용자의 직접에 보관 된 개체**등 sword 또는 총, 그립 자세를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-223">So, if you want to render **the user's hand** or **an object held in the user's hand**, such as a sword or gun, use the grip pose.</span></span> <span data-ttu-id="3c14c-224">예를 들어 사용자가 직접 또는 컨트롤러의 raycast 하려는 경우 **UI를 가리키는** 를 가리키는 자세를 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-224">If you want to raycast from the controller or hand, for example when the user is **pointing at UI** , use the pointing pose.</span></span>

<span data-ttu-id="3c14c-225">액세스할 수 있습니다 합니다 **그립 포즈** 를 통해 [SpatialInteractionSourceState::Properties::TryGetLocation(...) ](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourceproperties.trygetlocation#Windows_UI_Input_Spatial_SpatialInteractionSourceProperties_TryGetLocation_Windows_Perception_Spatial_SpatialCoordinateSystem_).  다음과 같이 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-225">You can access the **grip pose** through [SpatialInteractionSourceState::Properties::TryGetLocation(...)](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourceproperties.trygetlocation#Windows_UI_Input_Spatial_SpatialInteractionSourceProperties_TryGetLocation_Windows_Perception_Spatial_SpatialCoordinateSystem_).  It is defined as follows:</span></span>
* <span data-ttu-id="3c14c-226">합니다 **위치를 잡고**: 물론 컨트롤러를 보유 하는 경우 팜 중심 왼쪽 또는 오른쪽 가운데 그립 내의 위치를 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-226">The **grip position**: The palm centroid when holding the controller naturally, adjusted left or right to center the position within the grip.</span></span>
* <span data-ttu-id="3c14c-227">합니다 **방향을 올바른 축 잡고**: 완전히 플랫 5 손가락 자세를 직접 열면 광선과 표준 프로그램 palm에서 (왼쪽된 palm, palm 오른쪽에서 이전 버전과에서 앞으로)</span><span class="sxs-lookup"><span data-stu-id="3c14c-227">The **grip orientation's Right axis**: When you completely open your hand to form a flat 5-finger pose, the ray that is normal to your palm (forward from left palm, backward from right palm)</span></span>
* <span data-ttu-id="3c14c-228">합니다 **방향을 정방향 축 잡고**: 부분적으로 (처럼 컨트롤러 보유) 직접을 닫을 때, 광선을 가리키는 "forward" 튜브를 통해 비 엄지 손가락으로 구성 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-228">The **grip orientation's Forward axis**: When you close your hand partially (as if holding the controller), the ray that points "forward" through the tube formed by your non-thumb fingers.</span></span>
* <span data-ttu-id="3c14c-229">합니다 **축 위쪽 방향 잡고**: 오른쪽 정방향 정의 사용 권한에 포함 된 최대 축.</span><span class="sxs-lookup"><span data-stu-id="3c14c-229">The **grip orientation's Up axis**: The Up axis implied by the Right and Forward definitions.</span></span>

<span data-ttu-id="3c14c-230">액세스할 수 있습니다 합니다 **포인터 포즈** 를 통해 [SpatialInteractionSourceState::Properties::TryGetLocation (...):: SourcePointerPose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation#Windows_UI_Input_Spatial_SpatialInteractionSourceLocation_SourcePointerPose) 또는 [SpatialInteractionSourceState:: TryGetPointerPose (...):: TryGetInteractionSourcePose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialpointerpose#Windows_UI_Input_Spatial_SpatialPointerPose_TryGetInteractionSourcePose_Windows_UI_Input_Spatial_SpatialInteractionSource_)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-230">You can access the **pointer pose** through [SpatialInteractionSourceState::Properties::TryGetLocation(...)::SourcePointerPose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractionsourcelocation#Windows_UI_Input_Spatial_SpatialInteractionSourceLocation_SourcePointerPose) or [SpatialInteractionSourceState::TryGetPointerPose(...)::TryGetInteractionSourcePose](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialpointerpose#Windows_UI_Input_Spatial_SpatialPointerPose_TryGetInteractionSourcePose_Windows_UI_Input_Spatial_SpatialInteractionSource_).</span></span>

## <a name="controller-specific-input-properties"></a><span data-ttu-id="3c14c-231">컨트롤러 관련 입력된 속성</span><span class="sxs-lookup"><span data-stu-id="3c14c-231">Controller-specific input properties</span></span>
<span data-ttu-id="3c14c-232">컨트롤러에 대 한는 SpatialInteractionSource 추가 기능을 사용 하 여 컨트롤러 속성이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-232">For controllers, the SpatialInteractionSource has a Controller property with additional capabilities.</span></span>
* <span data-ttu-id="3c14c-233">**HasThumbstick:** True 이면 컨트롤러에는 엄지 스틱 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-233">**HasThumbstick:** If true, the controller has a thumbstick.</span></span> <span data-ttu-id="3c14c-234">검사는 [ControllerProperties](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractioncontrollerproperties) 스틱을 가져오려고 SpatialInteractionSourceState 속성 x 및 y 값 (ThumbstickX 및 ThumbstickY) 뿐만 아니라 누름된 상태로 (IsThumbstickPressed).</span><span class="sxs-lookup"><span data-stu-id="3c14c-234">Inspect the [ControllerProperties](https://docs.microsoft.com/uwp/api/windows.ui.input.spatial.spatialinteractioncontrollerproperties) property of the SpatialInteractionSourceState to acquire the thumbstick x and y values (ThumbstickX and ThumbstickY), as well as its pressed state (IsThumbstickPressed).</span></span>
* <span data-ttu-id="3c14c-235">**HasTouchpad:** True 이면 컨트롤러에는 터치 패드를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-235">**HasTouchpad:** If true, the controller has a touchpad.</span></span> <span data-ttu-id="3c14c-236">터치 패드를 가져오려고 SpatialInteractionSourceState의 ControllerProperties 속성을 검사할 x 및 y 값 (TouchpadX 및 TouchpadY) 및 사용자 (IsTouchpadTouched) 패드 접촉 되어 및 터치 패드 (축소 키를 눌러는 경우 IsTouchpadPressed)입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-236">Inspect the ControllerProperties property of the SpatialInteractionSourceState to acquire the touchpad x and y values (TouchpadX and TouchpadY), and to know if the user is touching the pad (IsTouchpadTouched) and if they are pressing the touchpad down (IsTouchpadPressed).</span></span>
* <span data-ttu-id="3c14c-237">**SimpleHapticsController:** SimpleHapticsController API 컨트롤러를 사용 하면 컨트롤러의 haptics 기능을 검사할 수 있습니다 하 고 햅 틱 피드백을 제어할 수도 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-237">**SimpleHapticsController:** The SimpleHapticsController API for the controller allows you to inspect the haptics capabilities of the controller, and it also allows you to control haptic feedback.</span></span>

<span data-ttu-id="3c14c-238">터치 패드 및 엄지 스틱의 범위는-1과 1 양 축에 대 한 (위쪽, 아래쪽에서 및 왼쪽에서 오른쪽) note 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-238">Note that the range for touchpad and thumbstick is -1 to 1 for both axes (from bottom to top, and from left to right).</span></span> <span data-ttu-id="3c14c-239">SpatialInteractionSourceState::SelectPressedValue 속성을 사용 하 여 액세스할을 수 있는 아날로그 트리거에 대 한 범위는 0 ~ 1 범위를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-239">The range for the analog trigger, which is accessed using the SpatialInteractionSourceState::SelectPressedValue property, has a range of 0 to 1.</span></span> <span data-ttu-id="3c14c-240">값이 true로 같다고 IsSelectPressed와 1 상관 관계가 지정 다른 값 IsSelectPressed false 같지 않은지를 사용 하 여 상관 관계를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-240">A value of 1 correlates with IsSelectPressed being equal to true; any other value correlates with IsSelectPressed being equal to false.</span></span>

## <a name="articulated-hand-tracking"></a><span data-ttu-id="3c14c-241">명확 하 고 직접 추적</span><span class="sxs-lookup"><span data-stu-id="3c14c-241">Articulated hand tracking</span></span>
<span data-ttu-id="3c14c-242">Windows Mixed Reality API 추적, 예를 들어 HoloLens 2에서 명확 하 고 직접 전체 지원을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-242">The Windows Mixed Reality API provides full support for articulated hand tracking, for example on HoloLens 2.</span></span> <span data-ttu-id="3c14c-243">응용 프로그램에서 직접 조작 및 지점 커밋 입력된 모델을 구현 하 추적 명확 하 고 직접 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-243">Articulated hand tracking can be used to implement direct manipulation and point-and-commit input models in your applications.</span></span> <span data-ttu-id="3c14c-244">완전히 사용자 지정 상호 작용을 작성 하려면 데도 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-244">It can also be used to author fully custom interactions.</span></span>

### <a name="hand-skeleton"></a><span data-ttu-id="3c14c-245">직접 스 켈 레 톤</span><span class="sxs-lookup"><span data-stu-id="3c14c-245">Hand skeleton</span></span>
<span data-ttu-id="3c14c-246">추적 명확 하 고 직접 다양 한 유형의 상호 작용을 사용 하도록 설정 하는 25 공동 구조를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-246">Articulated hand tracking provides a 25 joint skeleton that enables many different types of interactions.</span></span>  <span data-ttu-id="3c14c-247">인덱스/중간/링/거의 손가락에 대 한 5이 음, thumb에서 4이 음 및 1 손목 공동 구조를 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-247">The skeleton provides 5 joints for the index/middle/ring/little fingers, 4 joints for the thumb, and 1 wrist joint.</span></span>  <span data-ttu-id="3c14c-248">손목 연결점 계층의 기반으로 사용 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-248">The wrist joint serves as the base of the hierarchy.</span></span> <span data-ttu-id="3c14c-249">다음 그림에서는 골격의 레이아웃을 보여 줍니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-249">The following picture illustrates the layout of the skeleton.</span></span>

![직접 스 켈 레 톤](images/hand-skeleton.png)

<span data-ttu-id="3c14c-251">대부분의 경우에서 각이 음 나타내는 뼈에 따라 명명 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-251">In most cases, each joint is named based on the bone that it represents.</span></span>  <span data-ttu-id="3c14c-252">모든 연결에서 두 뼈 되므로 해당 위치에서 자식 뼈에 따라 각 공동 명명 규칙을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-252">Since there are two bones at every joint, we use a convention of naming each joint based on the child bone at that location.</span></span>  <span data-ttu-id="3c14c-253">자식 본 다음 손목 멀리 뼈도 정의 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-253">The child bone is defined as the bone further from the wrist.</span></span>  <span data-ttu-id="3c14c-254">예를 들어는 "인덱스 Proximal" 공동 포함 인덱스 proximal 뼈의 시작 위치 및 해당 뼈의 방향입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-254">For example, the "Index Proximal" joint contains the beginning position of the index proximal bone, and the orientation of that bone.</span></span>  <span data-ttu-id="3c14c-255">뼈의 끝 위치를 포함 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-255">It does not contain the ending position of the bone.</span></span>  <span data-ttu-id="3c14c-256">하는 경우 얻게이 다음에서 계층의 "인덱스 중간" 공동의 공동 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-256">If you need that, you'd get it from the next joint in the hierarchy, the "Index Intermediate" joint.</span></span>

<span data-ttu-id="3c14c-257">25 계층적이 음 외에도 시스템 palm 연결점을 제공합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-257">In addition to the 25 hierarchical joints, the system provides a palm joint.</span></span>  <span data-ttu-id="3c14c-258">손바닥 골격 구조의 일부 일반적으로 간주 되지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-258">The palm is not typically considered part of the skeletal structure.</span></span>  <span data-ttu-id="3c14c-259">편리 하 게 손 모양 아이콘이 전체 위치 및 방향 으로만 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-259">It is provided only as a convenient way to get the hand's overall position and orientation.</span></span>

<span data-ttu-id="3c14c-260">각 연결에 대 한 다음과 같은 정보가 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-260">The following information is provided for each joint:</span></span>

| <span data-ttu-id="3c14c-261">이름</span><span class="sxs-lookup"><span data-stu-id="3c14c-261">Name</span></span> | <span data-ttu-id="3c14c-262">설명</span><span class="sxs-lookup"><span data-stu-id="3c14c-262">Description</span></span> |
|--- |--- |
|<span data-ttu-id="3c14c-263">위치</span><span class="sxs-lookup"><span data-stu-id="3c14c-263">Position</span></span> | <span data-ttu-id="3c14c-264">사용할 수는 이음새의 3D 위치 좌표 시스템을 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-264">3D position of the joint, available in any requested coordinate system.</span></span> |
|<span data-ttu-id="3c14c-265">방향</span><span class="sxs-lookup"><span data-stu-id="3c14c-265">Orientation</span></span> | <span data-ttu-id="3c14c-266">사용할 수는 뼈의 3D 방향을 좌표계를 요청 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-266">3D orientation of the bone, available in any requested coordinate system.</span></span> |
|<span data-ttu-id="3c14c-267">반경</span><span class="sxs-lookup"><span data-stu-id="3c14c-267">Radius</span></span> | <span data-ttu-id="3c14c-268">공동 위치에 있는 스킨의 화면 까지의 거리입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-268">Distance to surface of the skin at the joint position.</span></span> <span data-ttu-id="3c14c-269">직접 상호 작용 또는 손가락 너비를 사용 하는 시각화를 튜닝 하는 데 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-269">Useful for tuning direct interactions or visualizations that rely on finger width.</span></span> |
|<span data-ttu-id="3c14c-270">정확도</span><span class="sxs-lookup"><span data-stu-id="3c14c-270">Accuracy</span></span> | <span data-ttu-id="3c14c-271">이 연결 정보에 대 한 시스템 느낌 얼마나 자신에 힌트를 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-271">Provides a hint on how confident the system feels about this joint's information.</span></span> |

<span data-ttu-id="3c14c-272">함수를 통해 직접 스 켈 레 톤 데이터에 액세스할 수 있습니다 합니다 [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-272">You can access the hand skeleton data through a function on the [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate).</span></span>  <span data-ttu-id="3c14c-273">함수를 호출 [TryGetHandPose](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygethandpose#Windows_UI_Input_Spatial_SpatialInteractionSourceState_TryGetHandPose)를 호출 하는 개체를 반환할 [HandPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handpose)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-273">The function is called [TryGetHandPose](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate.trygethandpose#Windows_UI_Input_Spatial_SpatialInteractionSourceState_TryGetHandPose), and it returns an object called [HandPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handpose).</span></span>  <span data-ttu-id="3c14c-274">원본 명확 하 고 실습을 지원 하지 않는 경우이 함수는 null을 반환 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-274">If the source does not support articulated hands, then this function will return null.</span></span>  <span data-ttu-id="3c14c-275">HandPose를 만든 후 호출 하 여 현재 공동 데이터를 가져올 수 있습니다 [TryGetJoint](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handpose.trygetjoint#Windows_Perception_People_HandPose_TryGetJoint_Windows_Perception_Spatial_SpatialCoordinateSystem_Windows_Perception_People_HandJointKind_Windows_Perception_People_JointPose__), 연결점의 이름에 관심이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-275">Once you have a HandPose, you can get current joint data by calling [TryGetJoint](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handpose.trygetjoint#Windows_Perception_People_HandPose_TryGetJoint_Windows_Perception_Spatial_SpatialCoordinateSystem_Windows_Perception_People_HandJointKind_Windows_Perception_People_JointPose__), with the name of the joint you are interested in.</span></span>  <span data-ttu-id="3c14c-276">데이터가로 반환 되는 [JointPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.jointpose) 구조입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-276">The data is returned as a [JointPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.jointpose) structure.</span></span>  <span data-ttu-id="3c14c-277">다음 코드는 집게 손가락 팁의 위치를 가져옵니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-277">The following code gets the position of the index finger tip.</span></span> <span data-ttu-id="3c14c-278">변수의 *currentState* 의 인스턴스를 나타내며 [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-278">The variable *currentState* represents an instance of [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate).</span></span>

```cpp
using namespace winrt::Windows::Perception::People;
using namespace winrt::Windows::Foundation::Numerics;

auto handPose = currentState.TryGetHandPose();
if (handPose)
{
    JointPose joint;
    if (handPose.TryGetJoint(desiredCoordinateSystem, HandJointKind::IndexTip, joint))
    {
        float3 indexTipPosition = joint.Position;

        // Do something with the index tip position
    }
}
```

### <a name="hand-mesh"></a><span data-ttu-id="3c14c-279">직접 메시</span><span class="sxs-lookup"><span data-stu-id="3c14c-279">Hand mesh</span></span>

<span data-ttu-id="3c14c-280">완벽 하 게 deformable 삼각형 직접 메시에 대 한 API 추적 명확 하 고 손 모양 아이콘이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-280">The articulated hand tracking API allows for a fully deformable triangle hand mesh.</span></span>  <span data-ttu-id="3c14c-281">이 메시와 직접 스 켈 레 톤 함께 실시간에서 변형 수 하며 고급 물리학 기술 뿐만 아니라 시각화에 대 한 유용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-281">This mesh can deform in real time along with the hand skeleton, and is useful for visualization as well as advanced physics techniques.</span></span>  <span data-ttu-id="3c14c-282">직접 메시에 액세스 하려면 먼저 생성 해야는 [HandMeshObserver](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshobserver) 개체를 호출 하 여 [TryCreateHandMeshObserverAsync](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource.trycreatehandmeshobserverasync) 에 [SpatialInteractionSource](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-282">To access the hand mesh, you need to first create a [HandMeshObserver](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshobserver) object by calling [TryCreateHandMeshObserverAsync](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource.trycreatehandmeshobserverasync) on the [SpatialInteractionSource](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsource).</span></span>  <span data-ttu-id="3c14c-283">이 한 번 원본별, 일반적으로 처음 표시 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-283">This only needs to be done once per source, typically the first time you see it.</span></span>  <span data-ttu-id="3c14c-284">즉, 손 모양 FOV 들어갈 때마다 HandMeshObserver 개체를 만들려면이 함수를 호출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-284">That means you'll call this function to create a HandMeshObserver object whenever a hand enters the FOV.</span></span>  <span data-ttu-id="3c14c-285">이 비동기 함수를 동시성 여기의 비트를 사용 하 여 처리 해야 하므로 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-285">Note that this is an async function, so you'll have to deal with a bit of concurrency here.</span></span>  <span data-ttu-id="3c14c-286">를 사용할 수 있는 요청 HandMeshObserver 개체 삼각형 인덱스 버퍼를 호출 하 여 [GetTriangleIndices](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshobserver.gettriangleindices#Windows_Perception_People_HandMeshObserver_GetTriangleIndices_System_UInt16___)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-286">Once available, you can ask the HandMeshObserver object for the triangle index buffer by calling [GetTriangleIndices](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshobserver.gettriangleindices#Windows_Perception_People_HandMeshObserver_GetTriangleIndices_System_UInt16___).</span></span>  <span data-ttu-id="3c14c-287">해당 항목을 한 번 가져올 하 고 해당 원본의 수명에 대 한 캐시 수 있도록 인덱스 프레임을 통해 프레임을 변경 하지 마세요.</span><span class="sxs-lookup"><span data-stu-id="3c14c-287">Indices don't change frame over frame, so you can get those once and cache them for the lifetime of the source.</span></span>  <span data-ttu-id="3c14c-288">인덱스 감기 시계 방향 순서로 제공 됩니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-288">Indices are provided in clockwise winding order.</span></span>

<span data-ttu-id="3c14c-289">다음 코드는 메시 관찰자를 만들려면 분리 std::thread 스핀업 하 고 메시 관찰자를 사용할 수 있으면 인덱스 버퍼를 추출 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-289">The following code spins up a detached std::thread to create the mesh observer and extracts the index buffer once the mesh observer is available.</span></span>  <span data-ttu-id="3c14c-290">라는 변수에서 시작 *currentState*의 인스턴스인 [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) 나타내는 추적 된 손 모양입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-290">It starts from a variable called *currentState*, which is an instance of [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate) representing a tracked hand.</span></span>

```cpp
using namespace Windows::Perception::People;

std::thread createObserverThread([this, currentState]()
{
    HandMeshObserver newHandMeshObserver = currentState.Source().TryCreateHandMeshObserverAsync().get();
    if (newHandMeshObserver)
    {
        unsigned indexCount = newHandMeshObserver.TriangleIndexCount();
        vector<unsigned short> indices(indexCount);
        newHandMeshObserver.GetTriangleIndices(indices);

        // Save the indices and handMeshObserver for later use - and use a mutex to synchronize access if needed!
     }
});
createObserverThread.detach();
```
<span data-ttu-id="3c14c-291">분리 된 스레드를 시작 하는 것은 비동기 호출을 처리 하기 위한 하나의 옵션입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-291">Starting a detached thread is just one option for handling async calls.</span></span>  <span data-ttu-id="3c14c-292">또는 사용할 수 있습니다 새 [co_await](https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/concurrency) 기능에서 지원 되는 C++/WinRT 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-292">Alternatively, you could use the new [co_await](https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/concurrency) functionality supported by C++/WinRT.</span></span>

<span data-ttu-id="3c14c-293">HandMeshObserver 개체를 만든 후 해당 해당 SpatialInteractionSource 활성 상태인 동안 점유 해야 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-293">Once you have a HandMeshObserver object, you should hold onto it for the duration that its corresponding SpatialInteractionSource is active.</span></span>  <span data-ttu-id="3c14c-294">다음 각 프레임을 요청할 수 있습니다를 호출 하 여 손 모양 아이콘이 나타내는 최신 버텍스 버퍼에 대 한 [GetVertexStateForPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshobserver.getvertexstateforpose) 전달 된 [HandPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handpose) 꼭 짓 점 하려는 자세를 나타내는 인스턴스 에 대 한</span><span class="sxs-lookup"><span data-stu-id="3c14c-294">Then each frame, you can ask it for the latest vertex buffer that represents the hand by calling [GetVertexStateForPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshobserver.getvertexstateforpose) and passing in a [HandPose](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handpose) instance that represents the pose that you want vertices for.</span></span>  <span data-ttu-id="3c14c-295">버퍼의 각 꼭 짓 점 위치와 일반에 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-295">Each vertex in the buffer has a position and a normal.</span></span>  <span data-ttu-id="3c14c-296">직접 메시에 대 한 현재 꼭 짓 점 집합을 가져오는 방법의 예는 다음과 같습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-296">Here's an example of how to get the current set of vertices for a hand mesh.</span></span>  <span data-ttu-id="3c14c-297">이전과 마찬가지로 합니다 *currentState* 변수 인스턴스를 나타냅니다 [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-297">Just as before, the *currentState* variable represents an instance of [SpatialInteractionSourceState](https://docs.microsoft.com/en-us/uwp/api/windows.ui.input.spatial.spatialinteractionsourcestate).</span></span>

```cpp
using namespace winrt::Windows::Perception::People;

auto handPose = currentState.TryGetHandPose();
if (handPose)
{
    std::vector<HandMeshVertex> vertices(handMeshObserver.VertexCount());
    auto vertexState = handMeshObserver.GetVertexStateForPose(handPose);
    vertexState.GetVertices(vertices);

    auto meshTransform = vertexState.CoordinateSystem().TryGetTransformTo(desiredCoordinateSystem);
    if (meshTransform != nullptr)
    {
        // Do something with the vertices and mesh transform, along with the indices that you saved earlier
    }
}
```

<span data-ttu-id="3c14c-298">스 켈 레 톤이 음 달리 직접 메시 API 수 없도록 꼭 짓 점에 대 한 좌표 시스템을 지정할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-298">In contrast to skeleton joints, the hand mesh API does not allow you to specify a coordinate system for the vertices.</span></span>  <span data-ttu-id="3c14c-299">대신 합니다 [HandMeshVertexState](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshvertexstate) 꼭 짓 점을에서 제공 되는 좌표계를 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-299">Instead, the [HandMeshVertexState](https://docs.microsoft.com/en-us/uwp/api/windows.perception.people.handmeshvertexstate) specifies the coordinate system that the vertices are provided in.</span></span>  <span data-ttu-id="3c14c-300">메시 변환 호출 하 여 얻을 수 있습니다 [TryGetTransformTo](https://docs.microsoft.com/en-us/uwp/api/windows.perception.spatial.spatialcoordinatesystem.trygettransformto#Windows_Perception_Spatial_SpatialCoordinateSystem_TryGetTransformTo_Windows_Perception_Spatial_SpatialCoordinateSystem_) 원하는 좌표 시스템을 지정 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-300">You can then get a mesh transform by calling [TryGetTransformTo](https://docs.microsoft.com/en-us/uwp/api/windows.perception.spatial.spatialcoordinatesystem.trygettransformto#Windows_Perception_Spatial_SpatialCoordinateSystem_TryGetTransformTo_Windows_Perception_Spatial_SpatialCoordinateSystem_) and specifying your desired coordinate system.</span></span>  <span data-ttu-id="3c14c-301">꼭 짓 점을 사용 하 여 작업할 때마다이 메시 변환을 사용 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-301">You'll need to use this mesh transform whenever you work with the vertices.</span></span>  <span data-ttu-id="3c14c-302">이 방법은 메시 렌더링을 위해 사용 하는 경우에 특히 CPU 오버 헤드를 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-302">This approach reduces CPU overhead, especially if you are only using the mesh for rendering purposes.</span></span>

## <a name="gaze-and-commit-composite-gestures"></a><span data-ttu-id="3c14c-303">Gaze 및 복합 제스처 커밋</span><span class="sxs-lookup"><span data-stu-id="3c14c-303">Gaze and Commit composite gestures</span></span>
<span data-ttu-id="3c14c-304">HoloLens에서 특히 게이즈 커밋 입력된 모델을 사용 하 여 응용 프로그램에 대 한 (첫 번째 gen) 공간 입력 API가 제공 선택적인 [SpatialGestureRecognizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.spatial.spatialgesturerecognizer.aspx) 사용할 수 있는 기반으로 구축 하는 복합 제스처를 사용 하도록 설정 합니다 ' select' 이벤트입니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-304">For applications using the gaze-and-commit input model, particularly on HoloLens (first gen), the Spatial Input API provides an optional [SpatialGestureRecognizer](https://msdn.microsoft.com/library/windows/apps/windows.ui.input.spatial.spatialgesturerecognizer.aspx) that can be used to to enable composite gestures built on top of the 'select' event.</span></span>  <span data-ttu-id="3c14c-305">라우팅 상호 작용을 SpatialInteractionManager에서 홀로그램의 SpatialGestureRecognizer 하 여 앱 수 탭, 보류, 조작 및 탐색 이벤트 감지 균일 하 게 바늘, 음성 및 공간 입력된 장치에서 누름을 처리 하지 않고도 수동으로 해제 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-305">By routing interactions from the SpatialInteractionManager to a hologram's SpatialGestureRecognizer, apps can detect Tap, Hold, Manipulation, and Navigation events uniformly across hands, voice, and spatial input devices, without having to handle presses and releases manually.</span></span>

<span data-ttu-id="3c14c-306">SpatialGestureRecognizer 요청 하는 제스처 집합 간의 최소 명확성에만 수행 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-306">SpatialGestureRecognizer performs only the minimal disambiguation between the set of gestures that you request.</span></span> <span data-ttu-id="3c14c-307">예를 들어,만 Tap를 요청 하는 경우 사용자 수 누른 해당 손가락 있기만 원하는 탭 계속 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-307">For example, if you request just Tap, the user may hold their finger down as long as they like and a Tap will still occur.</span></span> <span data-ttu-id="3c14c-308">요청 하는 경우 모두 페이지를 누르고, 보류 승격 제스처는 해당 손가락 누르고의 보조에 대 한 후 탭을 더 이상 발생 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-308">If you request both Tap and Hold, after about a second of holding down their finger, the gesture will promote to a Hold and a Tap will no longer occur.</span></span>

<span data-ttu-id="3c14c-309">SpatialGestureRecognizer를 사용 하려면 SpatialInteractionManager의 처리할 [InteractionDetected](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialInteractionManager.InteractionDetected) 이벤트 및 잡기를 SpatialPointerPose 노출 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-309">To use SpatialGestureRecognizer, handle the SpatialInteractionManager's [InteractionDetected](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialInteractionManager.InteractionDetected) event and grab the SpatialPointerPose exposed there.</span></span> <span data-ttu-id="3c14c-310">상호 작용 하려는 의도 하는 사용자가 확인 하기 위해 사용자의 환경 등에서 화면 메시 및 교차 하 여 홀로그램이이 포즈에서 사용자의 헤드 게이즈 광선을 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-310">Use the user's head gaze ray from this pose to intersect with the holograms and surface meshes in the user's surroundings, in order to determine what the user is intending to interact with.</span></span> <span data-ttu-id="3c14c-311">그런 다음 대상 홀로그램의 SpatialGestureRecognizer 위해 이벤트 인수에는 SpatialInteraction 경로 사용 하 여 해당 [CaptureInteraction](http://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.CaptureInteraction) 메서드.</span><span class="sxs-lookup"><span data-stu-id="3c14c-311">Then, route the SpatialInteraction in the event arguments to the target hologram's SpatialGestureRecognizer, using its [CaptureInteraction](http://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.CaptureInteraction) method.</span></span> <span data-ttu-id="3c14c-312">해석에 따라 해당 상호 작용이 시작 됩니다 합니다 [SpatialGestureSettings](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureSettings) 생성 시-통하거나 해당 인식기 설정 [TrySetGestureSettings](http://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.TrySetGestureSettings)합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-312">This starts interpreting that interaction according to the [SpatialGestureSettings](https://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureSettings) set on that recognizer at creation time - or by [TrySetGestureSettings](http://msdn.microsoft.com/library/windows/apps/xaml/Windows.UI.Input.Spatial.SpatialGestureRecognizer.TrySetGestureSettings).</span></span>

<span data-ttu-id="3c14c-313">HoloLens에 (gen 먼저) 해당 사용자의 헤드 게이즈를에서 타기 팅 하기 보다는 동안 렌더링 또는 손 모양 아이콘이 위치에 직접 작용 상호 작용 및 제스처를 일반적으로 파생 되어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-313">On HoloLens (first gen), interactions and gestures should generally derive their targeting from the user's head gaze, rather than trying to render or interact at the hand's location directly.</span></span> <span data-ttu-id="3c14c-314">상호 작용 시작 된 후 조작 또는 탐색 제스처와 마찬가지로 제스처를 제어 하려면 손 모양 아이콘이의 상대적 동작을 사용할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="3c14c-314">Once an interaction has started, relative motions of the hand may be used to control the gesture, as with the Manipulation or Navigation gesture.</span></span>

## <a name="see-also"></a><span data-ttu-id="3c14c-315">참조</span><span class="sxs-lookup"><span data-stu-id="3c14c-315">See also</span></span>
* [<span data-ttu-id="3c14c-316">DirectX의 헤드 및 눈 응시</span><span class="sxs-lookup"><span data-stu-id="3c14c-316">Head and eye gaze in DirectX</span></span>](gaze-in-directx.md)
* [<span data-ttu-id="3c14c-317">입력된 모델을 직접 조작</span><span class="sxs-lookup"><span data-stu-id="3c14c-317">Direct manipulation input model</span></span>](direct-manipulation.md)
* [<span data-ttu-id="3c14c-318">지점 및 커밋 입력된 모델</span><span class="sxs-lookup"><span data-stu-id="3c14c-318">Point-and-commit input model</span></span>](point-and-commit.md)
* [<span data-ttu-id="3c14c-319">입력된 모델을 응시 및 커밋</span><span class="sxs-lookup"><span data-stu-id="3c14c-319">Gaze and commit input model</span></span>](gaze-and-commit.md)
* [<span data-ttu-id="3c14c-320">모션 컨트롤러</span><span class="sxs-lookup"><span data-stu-id="3c14c-320">Motion controllers</span></span>](motion-controllers.md)
