---
title: 홀로그램 안정성
description: HoloLens, 홀로그램을 자동으로 안정화도 단계 개발자 추가로 홀로그램 안정성을 향상 시킬 수 있습니다.
author: thetuvix
ms.author: alexturn
ms.date: 03/21/2018
ms.topic: article
keywords: hololens, 안정성, 홀로그램
ms.openlocfilehash: b35b904e3c662c5ebd0670a98044706fe208e348
ms.sourcegitcommit: c20563b8195c0c374a927b96708d958b127ffc8f
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/21/2019
ms.locfileid: "65974934"
---
# <a name="hologram-stability"></a><span data-ttu-id="8784d-104">홀로그램 안정성</span><span class="sxs-lookup"><span data-stu-id="8784d-104">Hologram stability</span></span>

<span data-ttu-id="8784d-105">안정적인 홀로그램을 위해 HoloLens 파이프라인이 기본 제공 이미지를 안정화 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-105">To achieve stable holograms, HoloLens has a built-in image stabilization pipeline.</span></span> <span data-ttu-id="8784d-106">안정화 파이프라인을 사용 하도록 설정 하는 데 필요한 추가 단계가 없습니다 있도록 백그라운드에서 자동으로 작동 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-106">The stabilization pipeline works automatically in the background, so there are no extra steps required to enable it.</span></span> <span data-ttu-id="8784d-107">그러나 개발자는 홀로그램 안정성을 개선 하는 기술을 연습 하 고 안정성을 저해 하는 시나리오를 방지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-107">However, developers should exercise techniques that improve hologram stability and avoid scenarios that reduce stability.</span></span>

## <a name="hologram-quality-terminology"></a><span data-ttu-id="8784d-108">홀로그램 품질 용어</span><span class="sxs-lookup"><span data-stu-id="8784d-108">Hologram quality terminology</span></span>

<span data-ttu-id="8784d-109">홀로그램의 품질에 적합 한 환경 및 응용 프로그램 개발의 결과입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-109">The quality of holograms is a result of good environment and good app development.</span></span> <span data-ttu-id="8784d-110">도달 하는 상수 60 프레임 초당 HoloLens는 운전자를 추적할 수 있는 환경에서 앱을 홀로그램과 일치 하는 좌표계는 동기화 해야 합니다. 사용자의 관점에서 고정 되도록는 홀로그램 환경 기준으로 이동 하지 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-110">Apps that hit a constant 60 frames-per-second in an environment where HoloLens can track the surroundings will ensure the hologram and the matching coordinate system are in sync. From a user's perspective, holograms that are meant to be stationary will not move relative to the environment.</span></span>

<span data-ttu-id="8784d-111">환경 실행 하면 일관 되지 않거나 낮은 렌더링 속도 또는 다른 앱 문제 표시, 다음과 같은 용어는 문제를 파악 하는 데 도움이 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-111">When environment issues, inconsistent or low rendering rates, or other app problems show up, the following terminology is helpful in identifying the problem.</span></span>
* <span data-ttu-id="8784d-112">**정확도입니다.**</span><span class="sxs-lookup"><span data-stu-id="8784d-112">**Accuracy.**</span></span> <span data-ttu-id="8784d-113">홀로그램 world 잠긴 실제 환경에 배치 되 고 여기서 배치 된, 주변 환경에 사용자 동작 또는 작고 스파스 환경 변경 사항에 대해 독립적 기준으로 그대로 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-113">Once the hologram is world-locked and placed in the real world, it should stay where it was placed, relative to the surrounding environment, independent of user motion or small and sparse environment changes.</span></span> <span data-ttu-id="8784d-114">홀로그램 나중에 표시 되 면 예기치 않은 위치를 하는 경우는 *정확도* 문제입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-114">If a hologram later appears in an unexpected location, it is an *accuracy* problem.</span></span> <span data-ttu-id="8784d-115">이러한 시나리오는 두 개의 고유 방 동일 하 게 보일 경우에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-115">Such scenarios can happen if two distinct rooms look identical.</span></span>
* <span data-ttu-id="8784d-116">**지터 합니다.**</span><span class="sxs-lookup"><span data-stu-id="8784d-116">**Jitter.**</span></span> <span data-ttu-id="8784d-117">사용자는 홀로그램의 빈도가 높은 흔들기으로이 준수 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-117">Users observe this as high frequency shaking of a hologram.</span></span> <span data-ttu-id="8784d-118">이 환경의 추적으로 인해 저하 되는 경우 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-118">This can happen when tracking of the environment degrades.</span></span> <span data-ttu-id="8784d-119">사용자에 대 한 솔루션이 실행 되 [센서 튜닝](sensor-tuning.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-119">For users, the solution is running [sensor tuning](sensor-tuning.md).</span></span>
* <span data-ttu-id="8784d-120">**Judder 합니다.**</span><span class="sxs-lookup"><span data-stu-id="8784d-120">**Judder.**</span></span> <span data-ttu-id="8784d-121">낮은 렌더링 빈도 균등 하지 않은 동작 및 홀로그램의 이미지를 두 번 발생합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-121">Low rendering frequencies result in uneven motion and double images of holograms.</span></span> <span data-ttu-id="8784d-122">이 동작을 사용 하 여 홀로그램에서 특히 뚜렷하게 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-122">This is especially noticeable in holograms with motion.</span></span> <span data-ttu-id="8784d-123">유지 관리 하는 데 필요한 개발자는 [상수 60 FPS](hologram-stability.md#frame-rate)합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-123">Developers need to maintain a [constant 60 FPS](hologram-stability.md#frame-rate).</span></span>
* <span data-ttu-id="8784d-124">**Drift.**</span><span class="sxs-lookup"><span data-stu-id="8784d-124">**Drift.**</span></span> <span data-ttu-id="8784d-125">사용자에 게 표시이 홀로그램 원래 위치에서 이동 하려면 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-125">Users see this as hologram appears to move away from where it was originally placed.</span></span> <span data-ttu-id="8784d-126">홀로그램에서 멀리 배치 된 경우에 이런 [공간 앵커](spatial-anchors.md)를 완벽 하 게 매핑되지 않은 환경 부분에서 특히 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-126">This happens when holograms are placed far away from [spatial anchors](spatial-anchors.md), particularly in parts of the environment that have not been fully mapped.</span></span> <span data-ttu-id="8784d-127">공간 앵커 가까운 홀로그램 만들기 드리프트의 가능성을 줄입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-127">Creating holograms close to spatial anchors lowers the likelihood of drift.</span></span>
* <span data-ttu-id="8784d-128">**Jumpiness 합니다.**</span><span class="sxs-lookup"><span data-stu-id="8784d-128">**Jumpiness.**</span></span> <span data-ttu-id="8784d-129">경우는 홀로그램 "pop" 또는 "이동"의 위치에서 가끔 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-129">When a hologram "pops" or "jumps" away from it's location occasionally.</span></span> <span data-ttu-id="8784d-130">홀로그램 환경 업데이트 이해에 맞게 조정 하는 추적으로 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-130">This can occur as tracking adjusts holograms to match updated understanding of your environment.</span></span>
* <span data-ttu-id="8784d-131">**Swim.**</span><span class="sxs-lookup"><span data-stu-id="8784d-131">**Swim.**</span></span> <span data-ttu-id="8784d-132">경우는 홀로그램 sway에 해당 하는 사용자의 헤드의 동작에 나타납니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-132">When a hologram appears to sway corresponding to the motion of the user's head.</span></span> <span data-ttu-id="8784d-133">홀로그램에 없을 때 발생 하는이 [안정화 평면](hologram-stability.md#stabilization-plane)에 HoloLens 않은 경우 [보정](calibration.md) 현재 사용자에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-133">This occurs when holograms are not on the [stabilization plane](hologram-stability.md#stabilization-plane), and if the HoloLens is not [calibrated](calibration.md) for the current user.</span></span> <span data-ttu-id="8784d-134">사용자를 다시 실행할 수는 [보정](calibration.md) 문제를 해결 하려면 응용 프로그램입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-134">The user can rerun the [calibration](calibration.md) application to fix this.</span></span> <span data-ttu-id="8784d-135">개발자는 안정성을 강화 하기 안정화 평면을 업데이트할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-135">Developers can update the stabilization plane to further enhance stability.</span></span>
* <span data-ttu-id="8784d-136">**색 구분 합니다.**</span><span class="sxs-lookup"><span data-stu-id="8784d-136">**Color separation.**</span></span> <span data-ttu-id="8784d-137">HoloLens에 표시 60hz (개별 색상 필드 240 Hz에 표시 됩니다)에서 빨간색-녹색-파랑-녹색의 색 채널을 flash는 색 순차적 표시가 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-137">The displays in HoloLens are a color sequential display, which flash color channels of red-green-blue-green at 60Hz (individual color fields are shown at 240Hz).</span></span> <span data-ttu-id="8784d-138">사용자가 자신의 눈을 사용 하 여 이동 홀로그램을 추적 하는 때마다 해당 홀로그램 선행 및 후행 가장자리를 rainbow 효과 생성, 구성 색 구분 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-138">Whenever a user tracks a moving hologram with his or her eyes, that hologram's leading and trailing edges separate in their constituent colors, producing a rainbow effect.</span></span> <span data-ttu-id="8784d-139">분리 정도 홀로그램의 속도 따라 결정 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-139">The degree of separation is dependent upon the speed of the hologram.</span></span> <span data-ttu-id="8784d-140">일부 드문 경우에서 고정 홀로그램 확인 하는 동안 신속 하 게 헤드 rainbow 효과 유발할 수도 있습니다 적용될지를 이동 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-140">In some rarer cases, moving ones head rapidly while looking at a stationary hologram can also result in a rainbow effect.</span></span> <span data-ttu-id="8784d-141">이 이라고  *[분리 색](hologram-stability.md#color-separation)* 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-141">This is called *[color separation](hologram-stability.md#color-separation)*.</span></span>

## <a name="frame-rate"></a><span data-ttu-id="8784d-142">프레임 속도</span><span class="sxs-lookup"><span data-stu-id="8784d-142">Frame rate</span></span>

<span data-ttu-id="8784d-143">프레임 속도 홀로그램 안정성의 첫 번째 기본 요소입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-143">Frame rate is the first pillar of hologram stability.</span></span> <span data-ttu-id="8784d-144">전 세계에서 안정적인 표시할 홀로그램, 사용자에 게 표시 하는 각 이미지에는 올바른 위치에 그릴 홀로그램 있어야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-144">For holograms to appear stable in the world, each image presented to the user must have the holograms drawn in the correct spot.</span></span> <span data-ttu-id="8784d-145">HoloLens 새로 고침 시간을 240 초 표시를 새로 마다 4 개의 별도 색 필드를 보여 주는 60 FPS (초당 프레임)의 사용자 환경에서 발생 하는 이미지를 렌더링 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-145">The displays on HoloLens refresh 240 times a second, showing four separate color fields for each newly rendered image, resulting in a user experience of 60 FPS (frames per second).</span></span> <span data-ttu-id="8784d-146">최상의 환경을 위해 응용 프로그램 개발자는 운영 체제에 새 이미지를 일관 되 게 16 밀리초 마다 제공 하는 데이 60 FPS를 유지 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-146">To provide the best experience possible, application developers must maintain 60 FPS, which translates to consistently providing a new image to the operating system every 16 milliseconds.</span></span>

<span data-ttu-id="8784d-147">**60 FPS** 실제 환경에서 사용 되지 않는 처럼 표현 홀로그램 그릴 HoloLens 사용자의 위치에서 이미지를 렌더링 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-147">**60 FPS** To draw holograms to look like they're sitting in the real world, HoloLens needs to render images from the user's position.</span></span> <span data-ttu-id="8784d-148">이미지 렌더링 시간이 걸리므로 HoloLens 이미지 표시에 표시 될 때 사용자의 헤드 될 위치를 예측 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-148">Since image rendering takes time, HoloLens predicts where a user's head will be when the images are shown in the displays.</span></span> <span data-ttu-id="8784d-149">이 예측 알고리즘은 근사치입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-149">This prediction algorithm is an approximation.</span></span> <span data-ttu-id="8784d-150">HoloLens 예측된 헤드 위치와 실제 헤드 위치 간의 불일치에 대 한 계정에 렌더링 되는 이미지를 조정 하는 하드웨어를 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-150">HoloLens has hardware that adjusts the rendered image to account for the discrepancy between the predicted head position and the actual head position.</span></span> <span data-ttu-id="8784d-151">이렇게이 하면 이미지를 사용자에 게 표시를 올바른 위치에서 렌더링 된 홀로그램 안정적인 것으로 생각 될 것 처럼 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-151">This makes the image the user sees appear as if it was rendered from the correct location, and holograms feel stable.</span></span> <span data-ttu-id="8784d-152">이미지 작업 가장 작은 변경 내용으로 업데이트를 하 고 동작 parallax 같은 렌더링 되는 이미지의 특정 작업을 완전히 해결할 수 없는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-152">The image updates work best with small changes, and it can't completely fix certain things in the rendered image like motion-parallax.</span></span>

<span data-ttu-id="8784d-153">60 FPS를 렌더링 하 여 안정적인 홀로그램을 확인 하려면 다음 세 가지를 수행 하는:</span><span class="sxs-lookup"><span data-stu-id="8784d-153">By rendering at 60 FPS, you are doing three things to help make stable holograms:</span></span>
1. <span data-ttu-id="8784d-154">이미지 및 사용자가 표시 되는 이미지 렌더링 간의 전체 대기 시간을 최소화 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-154">Minimizing the overall latency between rendering an image and that image being seen by the user.</span></span> <span data-ttu-id="8784d-155">게임 스레드 및 렌더링 스레드를 사용 하 여 엔진 30FPS를 실행 하는 연장선 상에 실행 추가 대기 시간이 33.3ms 추가할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-155">In an engine with a game thread and a render thread running in lockstep, running at 30FPS can add 33.3ms of extra latency.</span></span> <span data-ttu-id="8784d-156">대기 시간을 줄여이 예측 오차 줄어들고 홀로그램 안정성을 높입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-156">By reducing latency, this decreases prediction error, and increases hologram stability.</span></span>
2. <span data-ttu-id="8784d-157">사용자의 눈에 도달 하는 모든 이미지 일관 된 대기 시간을 갖도록 만들고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-157">Making it so every image reaching the user's eyes have a consistent amount of latency.</span></span> <span data-ttu-id="8784d-158">30fps를 렌더링 하는 경우 표시 이미지 60 FPS에 계속 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-158">If you render at 30fps, the display still displays images at 60 FPS.</span></span> <span data-ttu-id="8784d-159">즉, 동일한 이미지를 행에 두 번 표시 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-159">This means the same image will be displayed twice in a row.</span></span> <span data-ttu-id="8784d-160">두 번째 프레임 16.6ms 해야 합니다. 첫 번째 보다 더 많은 대기 시간 프레임 및 더 빈번히 양의 오류를 수정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-160">The second frame will have 16.6ms more latency than the first frame and will have to correct a more pronounced amount of error.</span></span> <span data-ttu-id="8784d-161">오류 크기에서의 이러한 불일치는 원치 않는 60hz judder를 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-161">This inconsistency in error magnitude can cause unwanted 60hz judder.</span></span>
3. <span data-ttu-id="8784d-162">Judder 모양의 줄이면는 특징은 균일 하지 않은 동작 및 double 이미지입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-162">Reducing the appearance of judder, which is characterized by uneven motion and double images.</span></span> <span data-ttu-id="8784d-163">더 빠른 홀로그램 동작 및 낮은 렌더링 속도 더 분명해 연관 judder 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-163">Faster hologram motion and lower render rates are associated with more pronounced judder.</span></span> <span data-ttu-id="8784d-164">따라서 60 FPS를 전혀 유지 하기 위해 노력 하 고 시간 없애는 데 도움이 됩니다 judder는 지정 된 이동 홀로그램에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-164">Therefore, striving to maintain 60 FPS at all times will help avoid judder for a given moving hologram.</span></span>

<span data-ttu-id="8784d-165">**프레임 속도 일관성** 프레임 속도 일관성은는 높은 프레임 초당 만큼 중요 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-165">**Frame-rate consistency** Frame rate consistency is as important as a high frames-per-second.</span></span> <span data-ttu-id="8784d-166">경우에 따라 삭제 프레임 풍부한 콘텐츠가 포함 응용 프로그램의 경우 피할 수 없는 하 고는 HoloLens 가끔 결함에서 복구 하기 위해 몇 가지 정교한 알고리즘을 구현 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-166">Occasionally dropped frames are inevitable for any content-rich application, and the HoloLens implements some sophisticated algorithms to recover from occasional glitches.</span></span> <span data-ttu-id="8784d-167">그러나 지속적으로 변화 framerate 훨씬 더 눈에 띄는 사용자에 게 보다 일관 되 게 낮은 프레임 속도로 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-167">However, a constantly fluctuating framerate is a lot more noticeable to a user than running consistently at lower frame rates.</span></span> <span data-ttu-id="8784d-168">예를 들어 5 프레임 (이러한 5 개 프레임의 기간에 대 한 60 FPS)에 대 한 원활 하 게 렌더링 한 후 다음 10 프레임 (30FPS 이러한 10 프레임 기간)에 대 한 다른 모든 프레임을 삭제 하는 응용 프로그램은 응용 프로그램 보다 더 안정적이 지는 일관 되 게 표시 30FPS를 렌더링합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-168">For example, an application that renders smoothly for 5 frames (60 FPS for the duration of these 5 frames) and then drops every other frame for the next 10 frames (30 FPS for the duration of these 10 frames) will appear more unstable than an application that consistently renders at 30 FPS.</span></span>

<span data-ttu-id="8784d-169">운영 체제는 30FPS까지 응용 프로그램을 제한 하는 데 관련에서 때 [혼합 현실 캡처](mixed-reality-capture.md) 실행 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-169">On a related note, the operating system will throttle applications down to 30 FPS when [mixed reality capture](mixed-reality-capture.md) is running.</span></span>

<span data-ttu-id="8784d-170">**성능 분석** 다양 한 도구와 같은 응용 프로그램 프레임 속도가 벤치 마크를 사용할 수 있는:</span><span class="sxs-lookup"><span data-stu-id="8784d-170">**Performance analysis** There are a variety of tools that can be used to benchmark your application frame rate such as:</span></span>
* <span data-ttu-id="8784d-171">GPUView</span><span class="sxs-lookup"><span data-stu-id="8784d-171">GPUView</span></span>
* <span data-ttu-id="8784d-172">Visual Studio 그래픽 디버거</span><span class="sxs-lookup"><span data-stu-id="8784d-172">Visual Studio Graphics Debugger</span></span>
* <span data-ttu-id="8784d-173">Unity와 같은 3D 엔진에 기본 제공 되는 프로파일러</span><span class="sxs-lookup"><span data-stu-id="8784d-173">Profilers built into 3D engines such as Unity</span></span>

## <a name="hologram-render-distances"></a><span data-ttu-id="8784d-174">홀로그램 렌더링 거리</span><span class="sxs-lookup"><span data-stu-id="8784d-174">Hologram render distances</span></span>

>[!VIDEO https://www.youtube.com/embed/-606oZKLa_s]

<span data-ttu-id="8784d-175">인간의 visual 시스템 fixates 때 개체에 중점을 두고 여러 거리 종속 신호를 통합 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-175">The human visual system integrates multiple distance-dependent signals when it fixates and focuses on an object.</span></span>
* <span data-ttu-id="8784d-176">[숙박](https://en.wikipedia.org/wiki/Accommodation_%28eye%29) -개별 주시 중점을 둡니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-176">[Accommodation](https://en.wikipedia.org/wiki/Accommodation_%28eye%29) - The focus of an individual eye.</span></span>
* <span data-ttu-id="8784d-177">[수렴](https://en.wikipedia.org/wiki/Convergence_(eye)) -안쪽으로 이동 하거나 바깥쪽 개체에 중점을 두 눈.</span><span class="sxs-lookup"><span data-stu-id="8784d-177">[Convergence](https://en.wikipedia.org/wiki/Convergence_(eye)) - Two eyes moving inward or outward to center on an object.</span></span>
* <span data-ttu-id="8784d-178">[관망 비전](https://en.wikipedia.org/wiki/Stereopsis) -들 고정 지점에서 개체의 거리에 종속 된 왼쪽 및 오른쪽 눈 이미지 간의 차이입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-178">[Binocular vision](https://en.wikipedia.org/wiki/Stereopsis) - Disparities between the left- and right-eye images that are dependent on an object's distance away from your fixation point.</span></span>
* <span data-ttu-id="8784d-179">음영, 상대 angular 크기 및 다른 monocular (단일 눈) 신호입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-179">Shading, relative angular size, and other monocular (single eye) cues.</span></span>

<span data-ttu-id="8784d-180">일치 및 숙박은 다양 한 거리에 있는 개체를 인지할 눈을 변경 하는 방법에 관련 된 매우 망막 신호 이기 때문에 고유 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-180">Convergence and accommodation are unique because they are extra-retinal cues related to how the eyes change to perceive objects at different distances.</span></span> <span data-ttu-id="8784d-181">자연 스러운 보고 수렴 및 숙박 연결 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-181">In natural viewing, convergence and accommodation are linked.</span></span> <span data-ttu-id="8784d-182">눈 (예: 코) 가까운 것을 볼 때 눈 간 및 near 지점으로 수용할 수 있도록 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-182">When the eyes view something near (e.g. your nose) the eyes cross and accommodate to a near point.</span></span> <span data-ttu-id="8784d-183">눈 눈 될 병렬 무한대와 눈 것으로 확인 되는 경우 무한대로 적용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-183">When the eyes view something at infinity the eyes become parallel and the eye accommodates to infinity.</span></span> <span data-ttu-id="8784d-184">HoloLens 착용 하는 사용자가 항상 광학 거리 2.0 m 약 사용자 반대쪽에 고정 된 HoloLens 표시 되기 때문에 명확한 이미지를 유지 하기 위해 2.0 m 수용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-184">Users wearing HoloLens will always accommodate to 2.0m to maintain a clear image because the HoloLens displays are fixed at an optical distance approximately 2.0m away from the user.</span></span> <span data-ttu-id="8784d-185">앱 개발자가 컨트롤을 다양 한 깊이 있는 내용 및 홀로그램을 배치 하 여 사용자의 눈을 수렴 하는 위치입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-185">App developers control where users' eyes converge by placing content and holograms at various depths.</span></span> <span data-ttu-id="8784d-186">수용 하 고 다른 간격으로 수렴을 두 큐 간의 자연 스러운 링크 중단 되며이 충돌의 크기가 큰 경우에 특히 visual 뜨거움 피로에 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-186">When users accommodate and converge to different distances, the natural link between the two cues are broken and this can lead to visual discomfort or fatigue, especially when the magnitude of the conflict is large.</span></span> <span data-ttu-id="8784d-187">뜨거움 vergence 숙박 충돌에서 방지할 또는 사용자 2.0 m 최대한 가깝게으로 수렴 하는 콘텐츠를 유지 하 여 최소화할 수 있습니다 (즉, 많은 깊이 사용 하 여 장면 배치 가능 하면 2.0 m 거의 관심 영역).</span><span class="sxs-lookup"><span data-stu-id="8784d-187">Discomfort from the vergence-accommodation conflict can be avoided or minimized by keeping content that users converge to as close to 2.0m as possible (i.e. in a scene with lots of depth place the areas of interest near 2.0m when possible).</span></span> <span data-ttu-id="8784d-188">콘텐츠를 배치할 수 없는 경우 vergence 참여사 충돌에서 거의 2.0 m 뜨거움 때 가장 큰 앞뒤로 다른 거리 간의 사용자 gaze의 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-188">When content cannot be placed near 2.0m discomfort from the vergence-accomodation conflict is greatest when user’s gaze back and forth between different distances.</span></span> <span data-ttu-id="8784d-189">즉, 훨씬 더 편리 하 게 확인을 고정 홀로그램 살펴봅니다를 홀로그램 50 cm 지금 보다 떨어진 50 cm 상태로 유지 되는 시간이 지남에 따라 사용자 반대쪽 및 방향으로 이동 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-189">In other words, it is much more comfortable to look at a stationary hologram that stays 50cm away than to look at a hologram 50cm away that moves toward and away from you over time.</span></span>

<span data-ttu-id="8784d-190">2.0 m에 콘텐츠를 배치 유용도 두 표시 하는 완벽 하 게이 거리에 겹치는 하도록 설계 되었습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-190">Placing content at 2.0m is also advantageous because the two displays are designed to fully overlap at this distance.</span></span> <span data-ttu-id="8784d-191">이 평면의 해제 배치 하는 이미지에 대 한 holographic 프레임의 밖 나가면서에서 사라집니다 계속 유지 하면서 다른 표시 하나 표시 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-191">For images placed off this plane, as they move off the side of the holographic frame they will disappear from one display while still being visible on the other.</span></span> <span data-ttu-id="8784d-192">이 관망 (대항)를 홀로그램으로 깊이 인식에 방해가 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-192">This binocular rivalry can be disruptive to the depth perception of the hologram.</span></span>

<span data-ttu-id="8784d-193">**사용자 로부터 홀로그램을 배치 하는 것에 대 한 최적의 거리**</span><span class="sxs-lookup"><span data-stu-id="8784d-193">**Optimal distance for placing holograms from the user**</span></span>

![사용자 로부터 홀로그램을 배치 하는 것에 대 한 최적의 거리](images/distanceguiderendering-750px.png)

<span data-ttu-id="8784d-195">**클립 평면** fadeout 1m에서 시작 하는 콘텐츠를 사용 하 여 85 cm에서 클리핑 렌더링 거리 좋습니다 최대 편안 하 게 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-195">**Clip Planes** For maximum comfort we recommend clipping render distance at 85cm with fadeout of content starting at 1m.</span></span> <span data-ttu-id="8784d-196">여기서 제공 및 사용자는 모두 고정 제공 하는 응용 프로그램에서 볼 수 있습니다와 가까운 편안 하 게 50 cm으로 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-196">In applications where holograms and users are both stationary holograms can be viewed comfortably as near as 50cm.</span></span> <span data-ttu-id="8784d-197">이러한 경우 응용 프로그램을 클립 면과 카메라를 30 cm 보다 더 가깝게 배치 해야 하 고 페이드 아웃을 적용 적어도 10 cm 클립 면과 카메라의에서 시작 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-197">In those cases, applications should place a clip plane no closer than 30cm and fade out should start at least 10cm away from the clip plane.</span></span> <span data-ttu-id="8784d-198">콘텐츠를 사용자 가까이 또는 홀로그램 멀어지는 방향으로 이동 자주 수행 하거나는 홀로그램 자주 이동 하려면 더 가깝게 또는 사용자 멀어지는 방향으로 이러한 상황에서 뜨거움 원인일 수는 반드시 85 cm 보다 좀 더 자세히 때마다 합니다 vergence 숙박 충돌 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-198">Whenever content is closer than 85cm it is important to ensure that users do not frequently move closer or farther from holograms or that holograms do not frequently move closer to or farther from the user as these situations are most likely to cause discomfort from the vergence-accommodation conflict.</span></span> <span data-ttu-id="8784d-199">콘텐츠는 85 cm 사용자 로부터 하지만 콘텐츠 85 cm는 가장 좋은 개발자를 위한 깊이 t의 25% 이상에서 사용자 및/또는 홀로그램을 이동 하지 마십시오 시나리오를 디자인 하는 것 보다 좀 더 자세히 렌더링 해야 하는 경우 보다 더 가깝게 상호 작용에 대 한 필요성을 최소화 하도록 설계 되어야 그 시간입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-199">Content should be designed to minimize the need for interaction closer than 85cm from the user, but when content must be rendered closer than 85cm a good rule of thumb for developers is to design scenarios where users and/or holograms do not move in depth more than 25% of the time.</span></span>

<span data-ttu-id="8784d-200">**모범 사례** 홀로그램 배치에 대 한 최적의 영역이 1.25 m ~ 5 분 홀로그램 2 분에 배치할 수 없습니다 하 고 수렴 숙박 사이의 충돌을 피할 수 없는 경우.</span><span class="sxs-lookup"><span data-stu-id="8784d-200">**Best practices** When holograms cannot be placed at 2m and conflicts between convergence and accommodation cannot be avoided, the optimal zone for hologram placement is between 1.25m and 5m.</span></span> <span data-ttu-id="8784d-201">디자이너에 항상 1 + 상호 작용 하도록 장려 하는 콘텐츠를 구성 해야 m 번 (예: 콘텐츠 크기를 조정 및 기본 배치 매개 변수).</span><span class="sxs-lookup"><span data-stu-id="8784d-201">In every case, designers should structure content to encourage users to interact 1+ m away (e.g. adjust content size and default placement parameters).</span></span>

## <a name="stabilization-plane"></a><span data-ttu-id="8784d-202">안정화 평면</span><span class="sxs-lookup"><span data-stu-id="8784d-202">Stabilization plane</span></span>
> [!NOTE]
> <span data-ttu-id="8784d-203">데스크톱 몰입 형 헤드셋에 대 한 안정화 평면 설정은 일반적으로 설정인 픽셀당 깊이 기반 reprojection를 사용 하도록 설정 하려면 시스템에 앱의 깊이 버퍼를 제공 하는 보다 적은 시각적 품질을 제공 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-203">For desktop immersive headsets, setting a stabilization plane is usually counter-productive, as it offers less visual quality than providing your app's depth buffer to the system to enable per-pixel depth-based reprojection.</span></span> <span data-ttu-id="8784d-204">HoloLens, 실행 하지 않는 한 설정 안정화 평면을 일반적으로 피해 야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-204">Unless running on a HoloLens, you should generally avoid setting the stabilization plane.</span></span>

<span data-ttu-id="8784d-205">HoloLens 복잡 한 하드웨어 기반 holographic 안정화 기법을 수행합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-205">HoloLens performs a sophisticated hardware-assisted holographic stabilization technique.</span></span> <span data-ttu-id="8784d-206">거의 자동 이며 장면에 애니메이션을 적용 하 고 사용자가 헤드 이동 동작 및 변경의 관점 (CameraPose)와 관련이 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-206">This is largely automatic and has to do with motion and change of the point of view (CameraPose) as the scene animates and the user moves their head.</span></span> <span data-ttu-id="8784d-207">안정화 평면 라는 단일 면이이 안정화를 최대화 하기 위해 선택 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-207">A single plane, called the stabilization plane, is chosen to maximize this stabilization.</span></span> <span data-ttu-id="8784d-208">장면에 모든 홀로그램 일부 안정화를 수신 하는 동안 안정화 평면에서 홀로그램 최대 하드웨어 안정화를 수신 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-208">While all holograms in the scene receive some stabilization, holograms in the stabilization plane receive the maximum hardware stabilization.</span></span>

![3D 개체에 대 한 안정화 평면](images/stab-plane-500px.jpg)

<span data-ttu-id="8784d-210">장치는 자동 선택이 평면을 시도 하지만 응용 프로그램은 장면에서의 포커스 지점을 선택 하 여이 프로세스에서 지원할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-210">The device will automatically attempt to choose this plane, but the application can assist in this process by selecting the focus point in the scene.</span></span> <span data-ttu-id="8784d-211">장면 요소 집중 하 고에 전달 하는 최상의 HoloLens에서 실행 중인 unity 앱을 선택 해야 [SetFocusPoint()](focus-point-in-unity.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-211">Unity apps running on a HoloLens should choose the best focus point based on your scene and pass this into [SetFocusPoint()](focus-point-in-unity.md).</span></span> <span data-ttu-id="8784d-212">DirectX의 포커스 지점을 설정 하는 예제는 기본 회전 큐브 템플릿에 포함 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-212">An example of setting the focus point in DirectX is included in the default spinning cube template.</span></span>

<span data-ttu-id="8784d-213">데스크톱 PC에 연결 하는 몰입 형 헤드셋에도 다른 여러 가지 Unity 앱을 실행 하면 Unity는 명시적 작업 없이 더 나은 이미지 품질 앱에서 일반적으로 제공 하는 픽셀 별 reprojection를 사용 하도록 설정 하려면 Windows 깊이 버퍼 제출 note 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-213">Note that when your Unity app runs on an immersive headset connected to a desktop PC, Unity will submit your depth buffer to Windows to enable per-pixel reprojection, which will usually provide even better image quality without explicit work by the app.</span></span> <span data-ttu-id="8784d-214">픽셀당 reprojection 재정의는 포커스 지점을 제공 하는 경우 있습니다 됩니다만 그렇게는 HoloLens에 앱이 실행 하는 경우.</span><span class="sxs-lookup"><span data-stu-id="8784d-214">If you provide a Focus Point, that will override the per-pixel reprojection, so you should only do so when your app is running on a HoloLens.</span></span>




```cs
// SetFocusPoint informs the system about a specific point in your scene to
// prioritize for image stabilization. The focus point is set independently
// for each holographic camera.
// You should set the focus point near the content that the user is looking at.
// In this example, we put the focus point at the center of the sample hologram,
// since that is the only hologram available for the user to focus on.
// You can also set the relative velocity and facing of that content; the sample
// hologram is at a fixed point so we only need to indicate its position.
renderingParameters.SetFocusPoint(
    currentCoordinateSystem,
    spinningCubeRenderer.Position
    );
```

<span data-ttu-id="8784d-215">포커스 지점 배치 하느냐에 달려를 홀로그램을 보고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-215">Placement of the focus point largely depends on the hologram is looking at.</span></span> <span data-ttu-id="8784d-216">앱 참조에 대 한 게이즈 벡터 있으며 앱 디자이너를 관찰 하면 원하는 내용을 알고 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-216">The app has the gaze vector for reference and the app designer knows what content they want the user to observe.</span></span>

<span data-ttu-id="8784d-217">개발자 홀로그램 안정화 할 수 있는 단일 가장 중요 한 사항은 60 FPS에 렌더링 하는 것입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-217">The single most important thing a developer can do to stabilize holograms is to render at 60 FPS.</span></span> <span data-ttu-id="8784d-218">60 FPS 아래 삭제 안정화 평면 최적화에 관계 없이 홀로그램 안정성을 급격히 줄어듭니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-218">Dropping below 60 FPS will dramatically reduce hologram stability, regardless of the stabilization plane optimization.</span></span>

<span data-ttu-id="8784d-219">**모범 사례** 안정화 평면을 설정 하려면 유니버설 방법이 있으면 및 앱 별 이므로 가장 적합 한 시나리오를 참조 하는 기본 것이 좋습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-219">**Best practices** There is no universal way to set up the stabilization plane and it is app-specific, so the main recommendation is to experiment and see what works best for your scenarios.</span></span> <span data-ttu-id="8784d-220">그러나이 평면에서 모든 콘텐츠를 완벽 하 게 안정화 때문에 최대한 많은 콘텐츠를 사용 하 여 안정화 평면을 정렬 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-220">However, try to align the stabilization plane with as much content as possible because all the content on this plane is perfectly stabilized.</span></span>

<span data-ttu-id="8784d-221">예를 들어 다음과 같은 가치를 제공해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-221">For example:</span></span>
* <span data-ttu-id="8784d-222">콘텐츠가 있는 경우만 평면 (읽기 앱, 비디오 재생 앱)를 평면으로 안정화 평면 정렬 된 콘텐츠입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-222">If you have only planar content (reading app, video playback app), align the stabilization plane with the plane that has your content.</span></span>
* <span data-ttu-id="8784d-223">3 작은 구를 world 잠금이 설정 된 경우 모든 구 센터는 현재 사용자의 보기는 있지만 "cut" 안정화 평면을 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-223">If there are 3 small spheres that are world-locked, make the stabilization plane "cut" though the centers of all the spheres that are currently in the user's view.</span></span>
* <span data-ttu-id="8784d-224">장면 크게 다른 깊이에 콘텐츠가 있으면 개체 더 선호 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-224">If your scene has content at substantially different depths, favor further objects.</span></span>
* <span data-ttu-id="8784d-225">홀로그램 사용자와 일치 하는 프레임 마다 보고 안정화 위치를 조정 해야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-225">Make sure to adjust the stabilization point every frame to coincide with the hologram the user is looking at</span></span>

<span data-ttu-id="8784d-226">**하지 말고 사항이** 안정화 평면은 뛰어난 도구를 달성 하는 경우 잘못 사용 하지만 안정적인 홀로그램 심각한 이미지 불안정 발생할 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-226">**Things to Avoid** The stabilization plane is a great tool to achieve stable holograms, but if misused it can result in severe image instability.</span></span>
* <span data-ttu-id="8784d-227">"Fire and forget" 하지로 끝날 수는 안정화 사용자 뒤 평면 되거나 더 이상 사용자의 보기에 있는 개체에 연결 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-227">Don't "fire and forget", since you can end up with the stabilization plane behind the user or attached to an object that is no longer in the user's view.</span></span> <span data-ttu-id="8784d-228">일반 안정화 평면 반대 카메라 전달 (예:-camera.forward) 설정 되어 있는지 확인</span><span class="sxs-lookup"><span data-stu-id="8784d-228">Ensure the stabilization plane normal is set opposite camera-forward (e.g. -camera.forward)</span></span>
* <span data-ttu-id="8784d-229">안정화 평면 양 극단 사이 신속 하 게 변경 하지 마세요</span><span class="sxs-lookup"><span data-stu-id="8784d-229">Don't rapidly change the stabilization plane back and forth between extremes</span></span>
* <span data-ttu-id="8784d-230">고정 된 거리/방향으로 설정 하 여 안정화 평면 둬서는 안</span><span class="sxs-lookup"><span data-stu-id="8784d-230">Don't leave the stabilization plane set to a fixed distance/orientation</span></span>
* <span data-ttu-id="8784d-231">사용자가 잘라내기 안정화 평면을 허용 하지 마십시오</span><span class="sxs-lookup"><span data-stu-id="8784d-231">Don't let the stabilization plane cut through the user</span></span>
* <span data-ttu-id="8784d-232">하지는 HoloLens 하지 않고 PC는 데스크톱에서 실행 하는 경우의 포커스 지점을 설정 하 고 픽셀당 깊이 기반 reprojection 대신 사용 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-232">Don't set the focus point when running on a desktop PC rather than a HoloLens, and instead rely on per-pixel depth-based reprojection.</span></span>

## <a name="color-separation"></a><span data-ttu-id="8784d-233">색 구분</span><span class="sxs-lookup"><span data-stu-id="8784d-233">Color separation</span></span> 

<span data-ttu-id="8784d-234">HoloLens 표시의 특성상 "색 분리"를 호출 하는 아티팩트 때로는 감지 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-234">Due to the nature of HoloLens displays, an artifact called "color-separation" can sometimes be perceived.</span></span> <span data-ttu-id="8784d-235">기본 색을 각각-빨강, 녹색 및 파랑를 분리 하는 이미지와 매니페스트 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-235">It manifests as the image separating into individual base colors - red, green and blue.</span></span> <span data-ttu-id="8784d-236">많은 양의 빨강, 녹색 및 파랑이 있기 때문에 흰색 개체를 표시할 때 아티팩트 특히 볼 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-236">The artifact can be especially visible when displaying white objects, since they have large amounts of red, green and blue.</span></span> <span data-ttu-id="8784d-237">사용자는 홀로그램을 시각적으로 추적 하는 경우 가장 발음는 빠른 속도로 holographic 프레임 간에 이동 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-237">It is most pronounced when a user visually tracks a hologram that is moving across the holographic frame at high speed.</span></span> <span data-ttu-id="8784d-238">아티팩트를 확인할 수 있습니다. 또 다른 방법은 개체 래핑/변형 됩니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-238">Another way the artifact can manifest is warping/deformation of objects.</span></span> <span data-ttu-id="8784d-239">개체에 고대비 및/또는 순수 색 (빨강, 녹색, 파랑) 색 구분 래핑 개체의 다양 한 부분으로 간주 될 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-239">If an object has high contrast and/or pure colors (red, green, blue), color-separation will be perceived as warping of different parts of the object.</span></span>

<span data-ttu-id="8784d-240">**사용자가 헤드를 회전할 때 어떤 색 분리 헤드 잠긴 흰색 원형 커서의 예가 같을 수 있습니다.**</span><span class="sxs-lookup"><span data-stu-id="8784d-240">**Example of what the color separation of a head-locked white round cursor could look like as a user rotates their head to the side:**</span></span>

![사용자가 헤드를 회전할 때 어떤 색 분리 헤드 잠긴 흰색 원형 커서의 예가 다음과 같을 수 있습니다.](images/colorseparationofroundwhitecursor-300px.png)

<span data-ttu-id="8784d-242">완전히 색 구분을 방지 하기 어려운 것 문제를 완화 하려면 사용할 수 있는 방법은 여러 가지가 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-242">Though it's difficult to completely avoid color separation, there are several techniques available to mitigate it.</span></span>

<span data-ttu-id="8784d-243">**색 구분을 확인할 수 있습니다.**</span><span class="sxs-lookup"><span data-stu-id="8784d-243">**Color-separation can be seen on:**</span></span>
* <span data-ttu-id="8784d-244">이동 하는 신속 하 게 같은 헤드 잠긴 개체를 포함 하 여 개체를 [커서](cursors.md)합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-244">Objects that are moving quickly, including head-locked objects such as the [cursor](cursors.md).</span></span>
* <span data-ttu-id="8784d-245">대체로 훨씬에서 개체를 [안정화 평면](hologram-stability.md#stabilization-plane)합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-245">Objects that are substantially far from the [stabilization plane](hologram-stability.md#stabilization-plane).</span></span>

<span data-ttu-id="8784d-246">**에 색 구분의 효과 감소:**</span><span class="sxs-lookup"><span data-stu-id="8784d-246">**To attenuate the effects of color-separation:**</span></span>
* <span data-ttu-id="8784d-247">사용자의 게이즈를 지연 하는 개체를 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-247">Make the object lag the user's gaze.</span></span> <span data-ttu-id="8784d-248">처럼 일부 관성 고 스프링""에 응시에 연결 된 나타나야 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-248">It should appear as if it has some inertia and is attached to the gaze "on springs".</span></span> <span data-ttu-id="8784d-249">(거리 줄이기) 커서 느려지고 사용자의 가능성이 게이즈 지점 뒤에 넣습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-249">This slows the cursor (reducing separation distance) and puts it behind the user's likely gaze point.</span></span> <span data-ttu-id="8784d-250">사용자가 게이즈 이동이 중지 되 면 신속 하 게 catch 하기만 매우 자연 스러운 느낌입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-250">So long as it quickly catches up when the user stops shifting their gaze it feels quite natural.</span></span>
* <span data-ttu-id="8784d-251">홀로그램 이동 하려는 수행 하는 경우는 사용자는 그 뒤에 눈을 예상 하는 경우 5도 초당 아래 해당 이동 속도 유지 하려고 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-251">If you do want to move a hologram, try to keep it's movement speed below 5 degrees/second if you anticipate that the user will follow it with their eyes.</span></span>
* <span data-ttu-id="8784d-252">사용 하 여 *light* of *기 하 도형* 커서에 대 한 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-252">Use *light* instead of *geometry* for the cursor.</span></span> <span data-ttu-id="8784d-253">게이즈를 연결할 가상 조명 원본 대화형 포인터로 간주 될 수 있지만 색 구분을 발생 하지는 않습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-253">A source of virtual illumination attached to the gaze will be perceived as an interactive pointer but will not cause color-separation.</span></span>
* <span data-ttu-id="8784d-254">안정화 평면에서 사용자는 gazing 홀로그램에 맞게 조정 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-254">Adjust the stabilization plane to match the holograms the user is gazing at.</span></span>
* <span data-ttu-id="8784d-255">개체 빨강, 녹색 또는 파란색 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-255">Make the object red, green or blue.</span></span>
* <span data-ttu-id="8784d-256">콘텐츠의 흐리게 표시 된 버전으로 전환 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-256">Switch to a blurred version of the content.</span></span> <span data-ttu-id="8784d-257">예를 들어, round 흰색 커서 변경 동작의 방향을 지향 약간 흐리게 표시 된 줄 수 있습니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-257">For example, a round white cursor could be change to a slightly blurred line oriented in the direction of motion.</span></span>

<span data-ttu-id="8784d-258">로 이전에 60 FPS에서 렌더링 안정화 평면 설정와 홀로그램 안정성에 대 한 가장 중요 한 기술입니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-258">As before, rendering at 60 FPS and setting the stabilization plane are the most important techniques for hologram stability.</span></span> <span data-ttu-id="8784d-259">눈에 띄는 색 구분을 연결 하는 경우 먼저 프레임 속도가 기대를 충족 하는지 확인 합니다.</span><span class="sxs-lookup"><span data-stu-id="8784d-259">If facing noticeable color separation, first make sure the frame rate meets expectations.</span></span>

## <a name="see-also"></a><span data-ttu-id="8784d-260">참조</span><span class="sxs-lookup"><span data-stu-id="8784d-260">See also</span></span>
* [<span data-ttu-id="8784d-261">혼합된 현실에 대 한 성능 이해</span><span class="sxs-lookup"><span data-stu-id="8784d-261">Understanding Performance for Mixed Reality</span></span>](understanding-performance-for-mixed-reality.md)
* [<span data-ttu-id="8784d-262">색, 광원 및 재질</span><span class="sxs-lookup"><span data-stu-id="8784d-262">Color, light and materials</span></span>](color,-light-and-materials.md)
* [<span data-ttu-id="8784d-263">Instinctual 상호 작용</span><span class="sxs-lookup"><span data-stu-id="8784d-263">Instinctual interactions</span></span>](interaction-fundamentals.md)